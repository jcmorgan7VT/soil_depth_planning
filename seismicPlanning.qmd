---
title: "gathering_data_4_18_24"
format: html
editor: visual
editor_options: 
  chunk_output_type: console
---

## Seismic field plan for summer 24

Gathering datasets to use to plan where seismic measurements will be made.

```{r setup-and-formatting-input-data}
library(pacman)
p_load(tidyverse, sp, mapview, tmap, stars,
       lubridate, gganimate, animation, patchwork, ggrepel, whitebox,
       terra,  tidyterra, mapview, ggnewscale, googlesheets4,
       gstat, # Variogram and krig functions
       spatialEco # Curvature function
       )

crs1 <- "PROJCRS[\"NAD83 / UTM zone 19N\",\n    BASEGEOGCRS[\"NAD83\",\n        DATUM[\"North American Datum 1983\",\n            ELLIPSOID[\"GRS 1980\",6378137,298.257222101,\n                LENGTHUNIT[\"metre\",1]]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4269]],\n    CONVERSION[\"UTM zone 19N\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",-69,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",0.9996,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",500000,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",0,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"(E)\",east,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"(N)\",north,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"Engineering survey, topographic mapping.\"],\n        AREA[\"North America - between 72°W and 66°W - onshore and offshore. Canada - Labrador; New Brunswick; Nova Scotia; Nunavut; Quebec. Puerto Rico. United States (USA) - Connecticut; Maine; Massachusetts; New Hampshire; New York (Long Island); Rhode Island; Vermont.\"],\n        BBOX[14.92,-72,84,-66]],\n    ID[\"EPSG\",26919]]"
#gathering datasets
# GIS files working directory
arsenal <- "/Users/johnmorgan/Documents/VT Research/HBTopmodel"
#watershed shapes to clip and mask by
#watershed boundary
w3_shed_location <- paste0(arsenal, "/w3_dems/w3_shed.tif")
w3_outline <- as.polygons(rast(w3_shed_location), extent=FALSE)
plot(w3_outline)

#topography- 1m hydro enforced DEM of the whole valley
#previously downloaded
dem_location <- paste0(arsenal, "/HB/1m hydro enforced DEM/dem1m.tif")
dem <- terra::rast(dem_location)
crop_dem <- crop(dem, w3_outline)
mask_dem <- mask(crop_dem, w3_outline)
plot(mask_dem) #currently in NAD83
#accurate flowlines of network
#using Carrie's flowlines
w3_stream <- vect(paste0(arsenal, "/HB/hbstream/hb42_master_startend.shp"))

w3_stream <- crop(w3_stream, w3_outline) #currently in NAD83
#classified stream map that scott sent me

# Think I will use Carrie's stream network instead of Scott's
w3_regime <- vect("~/Documents/VT Research/HB_data/headwater_streams_byflowregime/WS3_Streams_Types.shp")
plot(w3_regime) #currently in NAD83
#most recent soil map
#https://portal.edirepository.org/nis/mapbrowse?packageid=knb-lter-hbr.380.2
soil <- terra::rast("https://pasta.lternet.edu/package/data/eml/knb-lter-hbr/380/2/f083871fa0116b17b7398ca48eac7627")
crop_soil <- crop(soil, w3_outline)
mask_soil <- mask(crop_soil, w3_outline)
plot(mask_soil) #currently in NAD83
#locations and depths of soil pits, archive entry from Scott
#https://portal.edirepository.org/nis/metadataviewer?packageid=knb-lter-hbr.210.2
scott <- read_csv("https://pasta.lternet.edu/package/data/eml/knb-lter-hbr/210/2/42d7e94aea392080e7c40877c9a5df83")
scott_vect <- vect(scott, geom = c("easting", "northing"), crs = crs1)
scott_vect <- crop(scott_vect, w3_outline)
plot(scott_vect)

scott_horizons <- read_csv("https://pasta.lternet.edu/package/data/eml/knb-lter-hbr/210/2/407e3b6b8b88aaf095f15efeb865efd6")

scott_rocks <- scott_horizons %>% 
  filter(horizon == "R") %>% 
  left_join(scott, by = "pedon") %>% 
  select(top_cm, easting, northing) %>% 
  rename(depth = top_cm) %>% 
  mutate(depth = depth/100) %>% 
  vect(., geom = c("easting", "northing"), crs = crs1) %>% 
  crop(., w3_outline)
#classifies depth with a classification column
#1 < 0.25m, 2 is 0.25 - 0.5 m, 3 is 0.5 - 1, 4 is 1 - 1.5, 5 is > 1.5
#does not include soil pits from lateral weathering drive, I think
#check this link, I think it is wrong 6/17/24
#scott2 <- read_csv()
#lat weathering pedons
lat_locs <- read_csv("https://pasta.lternet.edu/package/data/eml/knb-lter-hbr/361/3/bb91029a464278a2e47451aafec435c2") %>% 
  filter(base == "R")
#unsure if filtering just by base == R is enough, or if I should also filter to horizon == R
lat_depth <- read_csv("https://pasta.lternet.edu/package/data/eml/knb-lter-hbr/361/3/cca9cc4a0a7218d0602aede8f3f8697e") 
just_depths <- lat_depth %>% 
  select(pedon, base_cm) %>% 
  group_by(pedon) %>% 
  summarize(depth = max(base_cm))

lat_hit_rock <- 
  lat_locs %>% 
  left_join(just_depths, by = "pedon") %>% 
  select(easting, northing, depth) %>% 
  vect(., geom = c("easting", "northing"), crs = crs1) %>% 
  mutate(depth = depth/100)


plot(lat_hit_rock)
#GPR results

#groundwater well locations with associated depth
#metadata: https://portal.edirepository.org/nis/metadataviewer?packageid=knb-lter-hbr.161.4
#depth in cm
wells <- read_csv("https://pasta.lternet.edu/package/data/eml/knb-lter-hbr/161/4/1549ca484d74e547def10197e8c502dc") 
wells <- wells %>% mutate(Well_ID = toupper(Well_ID))

wells_depth <- read_csv("gw_wells_depth_to_rock.csv") %>% 
  rename(depth = "Depth to rock (m)",
         Well_ID = Name) %>% 
  select(Well_ID, depth) %>% 
  filter(depth != "-") %>% 
  mutate(depth = as.numeric(depth))
wells_vect <- wells %>% 
  left_join(wells_depth, by = "Well_ID") %>% 
  select(Latitude, Longitude, depth) %>%
  drop_na() %>% 
  vect(., geom = c("Longitude", "Latitude"), crs = "epsg:4326") %>% 
  terra::project(., crs(w3_outline)) 
# turns out there are only 4 deep wells with the depth associated...
plot(wells_vect)
#also have water depths: https://portal.edirepository.org/nis/dataviewer?packageid=knb-lter-hbr.161.4&entityid=32a138fa201cbe3b7d6766cadb266cba
#outcrops, from 1994 geologic map
rocks_1994 <- vect('~/Documents/VT Research/HBTopModel/HB/hbef_outcrops') %>% 
  crop(w3_outline)
# Other geologic map: 
# https://pubs.usgs.gov/of/2000/of00-045/of0045p1.pdf

john_rocks <- read_csv("JM_bedrock_outcrops.csv") %>% 
  select(lat, long) %>% 
  mutate(depth = as.numeric(0),
         source = "john_outcrops") %>% 
  vect(., geom = c("long", "lat"), crs = "epsg:4326") %>% 
    terra::project(., crs(w3_outline)) 


######### My passive seismic measurements #########
seis <- read_sheet("https://docs.google.com/spreadsheets/d/1lZ2OcMzP__2jjh9WS54Y9cm_KP4eASWoAppsooTLick/edit?gid=744520605#gid=744520605",
                    sheet = "combined") %>% 
  select(grilla_number, lat, long, quality, depth) %>% 
  filter(quality != "not sesame") %>% 
  filter(depth != "#DIV/0") %>% 
  mutate(depth = as.numeric(depth)) %>% 
  na.omit()
seis$depth <- as.numeric(seis$depth)

seis_vect <- vect(seis, geom=c("long", "lat"), crs="epsg:4326", keepgeom=FALSE) %>% 
  terra::project(crs(w3_outline))
plot(seis_vect)

######### 2019 REU auger investigation #########
# unclear what the best way to filter it will be...
read_csv("auger_depths.csv") %>% 
  rename(Site = "Site Name",
         Sub = "Subwatershed",
         interface = "Bottom Interface") %>% 
  left_join(read_csv("auger_locations_topo.csv"), by = c("Sub", "Site")) %>% 
  filter(interface == "R",
         Horizon == "R") %>% 
  select(Sub, Site, 'Top (cm)', x, y)

#filter 2019 auger investigation to just bedrock depths
auger <- read_csv("auger_depths.csv") %>% 
  rename(Site = "Site Name",
         Sub = "Subwatershed",
         interface = "Bottom Interface",
         top_cm = "Top (cm)") %>% 
  left_join(read_csv("auger_locations_topo.csv"), by = c("Sub", "Site")) %>% 
  filter(interface == "R") %>% 
  select(Sub, Site, top_cm, x, y) %>%
  group_by(Site, x, y, Sub) %>% 
  summarise(depth = max(top_cm)/100) %>% 
  ungroup() %>% 
  select(x, y, depth) %>% 
  mutate(source = "2019_auger") %>% 
    vect(., geom = c("x", "y"), crs = crs1)

```
```{r unused-datasets}
#soil depth from valley wide veg plots, from battles and fahey
#https://www.proquest.com/docview/304689277?pq-origsite=gscholar&fromopenview=true&sourcetype=Dissertations%20&%20Theses
# measured soil depth by inserting a steel probe until obstruction was encountered
# DOES NOT HAVE MEASUREMENTS IN W3
# fahey <- read_csv("https://pasta.lternet.edu/package/data/eml/knb-lter-hbr/121/5/d2a6900ad5470d00dce0d7fa0bca3eec") %>% vect(., geom = c("UTM_EASTING", "UTM_NORTHING"), crs = crs1)
# plot(fahey)
# plot(w3_outline, add = TRUE)
# plot(crop(fahey, w3_outline))


# Lat weathing rock https://drive.google.com/drive/folders/12HvDyet8GgEi490Ms0cnigfCRlMjnurT
#delineated rocky areas for Scott's 2019 paper
lat_rock <- vect("./ws3bedrock_latweathering/ws3bdrclip.shp")
plot(w3_outline)
plot(lat_rock, add = TRUE)

#Ksat measurements in W3
# Has depth associated with it but I am not sure that it is actually helpful
# ksat <- read_csv("https://pasta.lternet.edu/package/data/eml/knb-lter-hbr/364/1/1716abc55e229147fe45d60cbe7a4b65")

```

Right now, I have 6 sources of depth data:
- My seismic measurements
- Scott's soil pedons
- Lateral weathering pedons
- Scott's bedrock outcrop extent
- Rock outcrops from 1994 geologic map
- GW well depths
- Soil model (not sure how useful though)

Additional datasets I want/need to add:
- My observations of bedrock outcrops
- Georeferenced GPR cross sections and weasel road

old formatting chunk
```{r}
#basemap of W3
plot(w3_outline)
plot(w3_stream, add = TRUE)
#w3_shed_location <- paste0(arsenal, "/w3_dems/w3_shed.tif")
plot(scott_vect, add = TRUE)
plot(lat_hit_rock, add = TRUE)
plot(wells, add = TRUE)
plot(rocks, add = TRUE)
plot(seis_vect, add = TRUE)
plot(lat_rock, add = TRUE)

#normalize all datasets, plot together
scott_vect_norm <- scott_vect %>% 
  mutate(depth = depthclass * 0.25,
         source = "Scott Pedon Descriptions") %>% 
  select(depth, source)
lat_hit_rock_norm <- 
  lat_hit_rock %>% 
  mutate(depth = depth/100,
         source = "LatW. Pedon Descriptions") %>% 
  select(depth, source)
names(wells)
wells_norm <- wells %>% 
  mutate(depth = Max_depth/100,
         source = "GW wells") %>% 
  select(depth, source)
rocks_norm <- rocks %>% 
  mutate(depth = 0,
         source = "1994 Geologic Map outcrops") %>% 
  select(depth, source)

seis_vect_norm <- seis_vect %>% 
  mutate(source = "TROMINO seismic") %>% 
  select(depth, source)

combin_norm <- rbind(seis_vect_norm, rocks_norm, 
      wells_norm, lat_hit_rock_norm, scott_vect_norm) 


                              
```

Actual time to krig
- my seismic measurements
- 2019 depth surveys that hit rock
- wells that hit rock
- soil pits that hit rock
- my observations of bedrock outcrops
- geologic map outcrops
```{r}
# chunk to create depth shapefile, of points with appropriate information
# start with just my seismic measurements
all_sources <-
rbind(
#seis_sf2 <- 
  seis %>% 
group_by(lat, long) %>%       
  #remove duplicate locations by taking the mean
  summarise(mean_depth = mean(depth), n_coords = n()) %>% # n() is for looking duplicate number
  arrange(desc(n_coords)) %>%
  st_as_sf(coords = c("long", "lat"), crs = 4329) %>% 
  st_transform(crs1) %>% 
  rename(depth = mean_depth) %>% 
  select(depth) %>% 
  mutate(source = "seismic"),

st_as_sf(auger) %>% 
  mutate(source = "2019_auger"),

st_as_sf(wells_vect) %>% 
  mutate(source = "gw_wells"),

st_as_sf(lat_hit_rock) %>% 
  mutate(source = "lat_weathering"),

st_as_sf(scott_rocks) %>% 
  mutate(source = "scott_pedons"),

st_as_sf(rocks_1994) %>% 
  mutate(source = "rocks_1994",
         depth = as.numeric(0)) %>% 
  select(depth, geometry, source),

st_as_sf(john_rocks))


# input to kriging needs to be an sf object

# make a map showing input datasets and where they have coverage
combin_norm <- vect(all_sources)
  
ggplot()+
  geom_sf(data = w3_outline, fill = NA, alpha = 0.3, lwd = 1)+
  geom_sf(data = w3_stream, colour = "#9AC0CD", lwd = 1) +
  geom_sf(data = combin_norm, aes(fill = depth), size = 3, pch = 21) +
  
  scale_fill_gradient(high = "#27408B", low = "white")+
  facet_wrap(~source, ncol= 4)+
  theme_classic()+
  #geom_sf(data = w3_pour, colour = "black") +
   #scale_fill_hypso_c(palette = "dem_screen" , limits = c(200, 1000))+
  theme(rect = element_rect(fill = "transparent", color = NA),
        axis.title.x = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.line.x = element_blank(),
        axis.title.y = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.line.y = element_blank())
```


```{r}
# chunk that will run the variogram calculation and run kriging model

# create the empty grid to hold the output of kriging
st_bbox(w3_outline) |>
  st_as_stars(dx = 1) -> grd

#grd <- mask_dem

# Remove empty geometries
which(st_is_empty(all_sources))
all_sources <- all_sources[-which(st_is_empty(all_sources)),]
# Remove missing depth values, all 3 are in auger dataset
which(is.na(all_sources))
all_sources <-all_sources[-which(is.na(all_sources)),]

no_auger <- filter(all_sources, source != "2019_auger")

# calculate the sample variogram
v <- variogram(depth~1, no_auger)
#v <- variogram(depth~1, all_sources, cutoff = 445.8491, width = 37.15409)

# plot semivariogram
plot(v, plot.numbers = TRUE, xlab = "distance h [m]",
     ylab = expression(gamma(h)),
     xlim = c(0, 1.055 * max(v$dist)))

# fit a model/variogram to the data
v.m <- fit.variogram(v, vgm(1, "Exp", 10, 1))
plot(v, v.m, plot.numbers = TRUE, xlab = "distance h [m]",
     ylab = expression(gamma(h)),
     xlim = c(0, 1.055 * max(v$dist))) ## draws a single model; draw 2 models in single plot:
# use variogram model to krig
k <- krige(depth~1, all_sources, grd, v.m)
```

Krig again, but per Yang's suggestion exclude a validation dataset and use it to calculate RMSE
```{r}
set.seed(1)
no_auger <- filter(all_sources, source != "2019_auger")
df_form <- as_tibble(no_auger)
df_form$group_equal_range <- cut(df_form$depth, breaks = 5, labels = FALSE)

training <- df_form %>% 
  #group_by(group_equal_range) %>% 
  slice_sample(, prop = 0.7)

validation <- anti_join(df_form, training)
training_sf <- st_as_sf(training)
validation_vect <- vect(st_as_sf(validation))
# calculate the sample variogram
v <- variogram(depth~1, training_sf)
v.m <- fit.variogram(v, vgm(1, "Exp", 10, 1))
k <- krige(depth~1, training_sf, grd, v.m)

extract(rast(k), validation_vect, ID = FALSE, bind = TRUE) %>% 
  as_tibble() %>% 
  summarise(RMSE = sqrt(mean((depth - var1.pred_var1.pred)^2)))

```


Try multivariate approach
```{r topography-multivariate}
#extract topographic values for each input data location
combin_norm

plot(curve5)

extract(dem)
#flow accumulation/drainage area
mask_dem_location <- paste0(arsenal, "/w3_dems/1mdem_w3_masked.tif")
fill_output <- "./w3_dems/10mdem_fill.tif"

#flow accumulation/drainage area
flowacc_output <- paste0(arsenal,"/w3_dems/10mdem_flowacc.tif")

#Slope
slope_output <- paste0(arsenal,"/w3_dems/10mdem_slope.tif")

#calculate TPI
tpi_output <- paste0(arsenal,"/w3_dems/10mdem_tpi.tif")

#TWI
twi_output <- paste0(arsenal,"/w3_dems/10mdem_twi.tif")

w3_uaa <- 
  extract(rast(flowacc_output), combin_norm, ID = FALSE, bind = TRUE) %>% 
  rename("uaa" = `X10mdem_flowacc`) #%>% 
  #as_tibble()

w3_tpi <- extract(rast(tpi_output), combin_norm, ID = FALSE, bind = TRUE) %>% 
  rename("tpi" = `X10mdem_tpi`) %>% 
  #as_tibble() %>% 
  select(tpi)

w3_twi <- extract(rast(twi_output), combin_norm, ID = FALSE, bind = TRUE) %>% 
  rename("twi" = `X10mdem_twi`) %>% 
  #as_tibble() %>% 
  select(twi)

w3_slope <- extract(rast(slope_output), combin_norm, ID = FALSE, bind = TRUE) %>% 
  rename("slope" = `X10mdem_slope`) %>% 
  #as_tibble() %>% 
  select(slope)

w3_topo <- bind_spat_cols(w3_uaa, w3_twi, w3_tpi, w3_slope)

all_sources2 <- st_as_sf(w3_topo)
which(st_is_empty(all_sources2))
all_sources2 <- all_sources2[-which(st_is_empty(all_sources2)),]
# Remove missing depth values, all 3 are in auger dataset
which(is.na(all_sources2))
all_sources2 <-all_sources2[-which(is.na(all_sources2)),]

no_auger <- filter(all_sources2, source != "2019_auger")

# Multivariate kriging
hscat(log(depth) ~ 1, no_auger, (0:9) * 100)

 cok.maps <- predict(vm.fit, meuse.grid)
# calculate the sample variogram
v <- variogram(depth~1, no_auger)
#v <- variogram(depth~1, all_sources, cutoff = 445.8491, width = 37.15409)

# plot semivariogram
plot(v, plot.numbers = TRUE, xlab = "distance h [m]",
     ylab = expression(gamma(h)),
     xlim = c(0, 1.055 * max(v$dist)))

# fit a model/variogram to the data
v.m <- fit.variogram(v, vgm(1, "Exp", 10, 1))
plot(v, v.m, plot.numbers = TRUE, xlab = "distance h [m]",
     ylab = expression(gamma(h)),
     xlim = c(0, 1.055 * max(v$dist))) ## draws a single model; draw 2 models in single plot:
# use variogram model to krig
k <- krige(depth~1, all_sources, grd, v.m)
```

```{r W3-map}
#map of watershed 3 with depth to bedrock
hillshade_location <- paste0(arsenal, "/w3_dems/1mdem_hillshade.tif")
hill <- rast(hillshade_location) %>% 
  crop(w3_outline) %>% 
  mask(w3_outline)

#ybounds <- c(4870350,4871350)
#xbounds <- c(281350, 282150)
#crop to rectangular area
#crop1 <- crop(m1, ext(c(xbounds, ybounds)))
#writeRaster(crop1, "1mdemw3_cropped.tif")
plot(mask_dem)
k_terra <- rast(k) %>% 
  crop(w3_outline) %>% 
  mask(w3_outline) %>% 
  select(var1.pred_var1.pred)
# Save output krigged map for whitebox operations
plot(k_terra)
max(k_terra)
plot(-k_terra+10)

writeRaster(k_terra, "krig_output.tif", overwrite = TRUE)

#watershed boundary

plot(w3_outline)
#expanse(w3_outline)

plot(w3_stream)

#point locations- snapped points from above chunk
#w3_stic_locs_snap <- "w3_stic_locs_snap.shp"

# w3_stic_locs_r <- vect(w3_stic_locs_snap) %>% 
#   left_join(pks_w3, by = "ID")



#w3_stic_locs_r <- vect(w3_stic_locs_snap)
#writeVector(w3_stic_locs_r, "./seismic_map_exports/w3_stic_locs_snap.shp")



ggplot()+
  geom_spatraster(data = hill)+
  theme_void()+
  #theme(legend.position = "")+
  scale_fill_gradientn(colors = c("gray9", "gray48","lightgray", "white"),
                       na.value = "transparent",
                       guide = "none")+
    new_scale_fill() +
  geom_spatraster(data = k_terra, aes(fill = var1.pred_var1.pred))+
  scale_fill_viridis_c(na.value = "transparent", alpha = 0.7, name = "Depth (m)")+
    geom_sf(data = w3_stream, colour = "lightgray") +
geom_sf(data = as.contour(m11, nlevels = 30), color = "white", alpha = 0.3)+
  ggspatial::annotation_scale(location = 'tr',
                              pad_x = unit(0.4, "cm"),
                              pad_y = unit(1, "cm"))

ggplot()+
  
  theme_void()+
  #theme(legend.position = "")+
  geom_spatraster(data = k_terra, aes(fill = var1.pred_var1.pred))+
    scale_fill_continuous(na.value = "transparent", name = "Depth (m)", trans = "reverse")+
  #scale_fill_viridis_c(na.value = "transparent", name = "Depth (m)")+
  ggspatial::annotation_scale(location = 'tr',
                              pad_x = unit(0.4, "cm"),
                              pad_y = unit(1, "cm"))

# old map from other workind dir that I copied to here
# w3_map_f1 <- 
#   ggplot()+
#   geom_spatraster(data = hill)+
#   theme_void()+
#   #theme(legend.position = "")+
#   scale_fill_gradientn(colors = c("gray9", "gray48","lightgray", "white"),
#                        guide = "none")+
#     new_scale_fill() +
#   #geom_spatraster(data = crop1, alpha = 0.5)+
#   geom_sf(data = w3_outline, fill = NA, color = "#FFD166", alpha = 0.3, lwd = 2)+
#   geom_sf(data = w3_net, colour = "#9AC0CD", lwd = 2) +
#   geom_sf(data = w3_stic_locs_r, aes(fill = pk), size = 3, pch = 21) +
#   #geom_sf(data = dd, aes(color = (depth)), pch = 19, size = 3) +
#   scale_fill_gradient(high = "#27408B", low = "white", guide = "none")+
#   #geom_sf(data = w3_pour, colour = "black") +
#    #scale_fill_hypso_c(palette = "dem_screen" , limits = c(200, 1000))+
#   #theme(rect = element_rect(fill = "transparent", color = NA))+
#   ggspatial::annotation_scale(location = 'tr',
#                               pad_x = unit(0.4, "cm"),
#                               pad_y = unit(1, "cm"))
#                               
# w3_map_f1
# ggsave("w3_map_f1f.png", w3_map_f1 )

```


Sanity check- take all observations not used in krig- holes not to bedrock- and see if they could be dug with this depth raster!
```{r}

```

Run fill algorithm on bedrock raster, and then subtract to make a raster of depressional storage
```{r}
writeRaster(-k_terra+10, "krig_output.tif", overwrite = TRUE, NAflag=-9999, gdal="COMPRESS=NONE")

m10 <- aggregate(mask_dem, 5)
m11 <- resample(m10, k_terra, method = "bilinear")

plot(mask_dem - k_terra)
writeRaster(mask_dem$dem1m - k_terra$var1.pred_var1.pred, "bedrock_topo.tif", overwrite = TRUE, NAflag=-9999, gdal="COMPRESS=NONE")
plot(rast("bedrock_topo.tif"))

wbt_rust_backtrace(RUST_BACKTRACE = "0")
filled_krig_out <- "filled_krig.tif"
wbt_sink(input = "krig_output.tif",
                     output = filled_krig_out)
wbt_fill_depressions(dem = "krig_output.tif",
                     output = filled_krig_out)
wbt_breach_depressions(dem = "krig_output.tif",
                     output = filled_krig_out)
wbt_breach_depressions_least_cost(dem = "krig_output.tif",
                     output = filled_krig_out, dist = 300)


plot(rast(filled_krig_out))

plot(rast("krig_output.tif"))

# I don't know why but I have to run through all of this twice for it to actually work
breach_output <- "5m_breach.tif"
wbt_breach_depressions_least_cost(
  dem = "krig_output.tif",
  output = breach_output,
  dist = 5,
  fill = TRUE)

fill_output <- "5m_fill.tif"
wbt_fill_depressions_wang_and_liu(
  dem = breach_output,
  output = fill_output
)
#subsurface depressional storage
rast(fill_output)
plot(rast(fill_output) - rast("krig_output.tif"))

# bedrock topography
bedrock_loc <- "bedrock_topo.tif"
breach_output_rock <- "1m_breach_rock.tif"
wbt_breach_depressions_least_cost(
  dem = bedrock_loc,
  output = breach_output_rock,
  dist = 1,
  fill = TRUE)

fill_output_rock <- "1m_fill_rock.tif"
wbt_fill_depressions_wang_and_liu(
  dem = "bedrock_topo.tif",
  output = fill_output_rock
)
#subsurface depressional storage
plot(rast(fill_output_rock))

plot(k_terra)
terra::lines(as.contour(mask_dem, nlevels = 30), col = "white",alpha = 0.3)

contour(m11, add = TRUE, col = "white", nlevels = 30, labels = "")
plot(m11)
lines(as.contour(k_terra, nlevels = 30), col = "white")

contour(k_terra, add = TRUE, col = "white", nlevels = 30, labels = "")
```

```{r calculate-w3-topo}
#flow accumulation/upslope drainage area at 3 m resolution calculated earlier in markdown
flowacc_output <- "./HB/1m hydro enforced DEM/dem3m_flowacc.tif"

#convert STIC data to a SpatVector data format
locs_shape <- vect(w3_locs, 
                   geom=c("POINT_X", "POINT_Y"), 
                   crs = crs(rast(flowacc_output))) #set crs to NAD 83

#calculate 10m DEM, then breach and fill
dem <- "./HB/1m hydro enforced DEM/dem1m.tif"
m1 <- rast(dem)
m10 <- aggregate(m1, 10)
#save raster, because whitebox wants it is a files location instead of an object in R
writeRaster(m10, "./w3_dems/10mdem.tif", overwrite = TRUE)


breach_output <- "./w3_dems/10mdem_breach.tif"
wbt_breach_depressions_least_cost(
  dem = "./w3_dems/10mdem.tif",
  output = breach_output,
  dist = 10,
  fill = TRUE)

fill_output <- "./w3_dems/10mdem_fill.tif"
wbt_fill_depressions_wang_and_liu(
  dem = breach_output,
  output = fill_output
)

#flow accumulation/drainage area
flowacc_output <- "./w3_dems/10mdem_flowacc.tif"
wbt_d_inf_flow_accumulation(input = fill_output,
                            output = flowacc_output,
                            out_type = "Specific Contributing Area")
#Slope
slope_output <- "./w3_dems/10mdem_slope.tif"
wbt_slope(dem = fill_output,
          output = slope_output,
          units = "degrees")
#calculate TPI
tpi_output <- "./w3_dems/10mdem_tpi.tif"
wbt_relative_topographic_position(
    dem = fill_output, 
    output = tpi_output, 
    filterx=11, 
    filtery=11)
#TWI
twi_output <- "./w3_dems/10mdem_twi.tif"
wbt_wetness_index(sca = flowacc_output, #flow accumulation
                  slope = slope_output,
                  output = twi_output)


w3_uaa <- extract(rast(flowacc_output), locs_shape, ID = FALSE, bind = TRUE) %>% 
  rename("uaa" = `X10mdem_flowacc`) %>% 
  as_tibble() %>% 
  pivot_longer(-ID)

w3_tpi <- extract(rast(tpi_output), locs_shape, ID = FALSE, bind = TRUE) %>% 
  rename("tpi" = `X10mdem_tpi`) %>% 
  as_tibble() %>% 
  pivot_longer(-ID)

w3_twi <- extract(rast(twi_output), locs_shape, ID = FALSE, bind = TRUE) %>% 
  rename("twi" = `X10mdem_twi`) %>% 
  as_tibble() %>% 
  pivot_longer(-ID)

w3_slope <- extract(rast(slope_output), locs_shape, ID = FALSE, bind = TRUE) %>% 
  rename("slope" = `X10mdem_slope`) %>% 
  as_tibble() %>% 
  pivot_longer(-ID)

w3_topo <- rbind(w3_uaa, w3_twi, w3_tpi, w3_slope, w3_curve)

```
```{r calculate-curvature}
dem <- "./HB/1m hydro enforced DEM/dem1m.tif"
m1 <- rast(dem)
m10 <- aggregate(m1, 10)

# w3_shed <- "./w3_dems/w3_shed.tif"
# w3_outline <- as.polygons(rast(w3_shed), extent=FALSE)
# #FB
# fb_shed <- "./fb_dems/fb_shed.tif"
# fb_outline <- as.polygons(rast(fb_shed), extent=FALSE)
# #ZZ
# zz_shed <- "./zz_dems/zz_shed.tif"
# zz_outline <- as.polygons(rast(zz_shed), extent=FALSE)

# fb_curve <- m1 %>% 
#   crop(fb_outline) %>% 
#   mask(fb_outline) %>% 
#   spatialEco::curvature()
# zz_curve <- m1 %>% 
#   crop(zz_outline) %>% 
#   mask(zz_outline)%>% 
#   spatialEco::curvature()
# w3_curve <- m1 %>% 
#   crop(w3_outline) %>% 
#   mask(w3_outline)%>% 
#   spatialEco::curvature()
#curve1 <- spatialEco::curvature(m1)
curve10 <- spatialEco::curvature(m11, type = "planform")

w3_curve <- extract(curve10, w3_locs[,2:3]) %>% 
  rename("curvature" = dem1m) %>% 
  pivot_longer(-ID)
fb_curve <- extract(curve10, fb_locs[,2:3]) %>% 
  rename("curvature" = dem1m) %>% 
  pivot_longer(-ID)
zz_curve <- extract(curve10, zz_locs[,2:3]) %>% 
  rename("curvature" = dem1m) %>% 
  pivot_longer(-ID)
```

Table of metrics
```{r}
# first, delineate stream network according to topography

# convert stream network to polygon, or keep as raster, but snap STIC locations to stream network
#w3 network- thing I need to change
#read in shapefile of stream converted in ARC
vect_stream_path <- paste0(arsenal, "/AGU24posterAnalysis/vector_stream/vector_stream.shp")
#stream as a vector
vect_stream <- vect(vect_stream_path)
plot(vect_stream)

w3_stic_locs_snap <- paste0(arsenal, "/w3_stic_locs_snap.shp")
pks_w3 <- read_csv(paste0(arsenal, "/pks_w3.csv"))

w3_stic_locs_r <- vect(w3_stic_locs_snap) %>% 
  left_join(pks_w3, by = "ID")
# Delineate watersheds for each STIC location
d8 <- paste0(arsenal, "/w3_dems/1mdem_w3_d8pt.tif")
w3_sub_shed <- "w3_sub_sheds.tif"
wbt_watershed(d8_pntr = d8,
              pour_pts = w3_stic_locs_snap,
              output = w3_sub_shed)
plot(filter(rast(w3_sub_shed), w3_sub_sheds == 1))
plot(w3_outline, add = TRUE)
# within the watershed for each stic location, calculate the average of several topographic values:
# curvature, upslope area, upslope volume, total depression volume upslope
zones <- rast(w3_sub_shed)
# Zonal function- take zonal statistics
dem_r  <- resample(project(mask_dem, zones), zones, method="bilinear")
z_dem <- zonal(dem_r, zones, fun = "mean", na.rm = TRUE)
curve5 <- spatialEco::curvature(m11, type = "planform")
curv_r  <- resample(project(curve5, zones), zones, method="bilinear")

z_curv <- zonal(curv_r, zones, fun = "mean", na.rm = TRUE)

# upslope volume
bed_r  <- resample(project(k_terra, zones), zones, method="bilinear")
z_bed <- zonal(bed_r, zones, fun = "sum", na.rm = TRUE)
# total depression volume
dep_r  <- resample(project(rast(fill_output) - rast("krig_output.tif"), zones), zones, method="bilinear")
z_dep <- zonal(dep_r, zones, fun = "sum", na.rm = TRUE) %>% 
  mutate()

zone_stats <- bind_cols(z_dem, z_curv[,2], z_bed[,2], z_dep[,2]) %>% 
  as_tibble()

colnames(zone_stats) <- c("ID", "evelation", "curavture", "sub_volume", "depression_vol")

zone_stats %>% 
  left_join(pks_w3, by = "ID") %>% 
  select(-wshed) %>% 
  pivot_longer(c(-pk, -ID), values_to = "value", names_to = "names") %>% 
  ggplot(aes(x = pk, y = value, color = names))+
    geom_point()+
  geom_smooth(method = 'lm', se = FALSE)+
    facet_wrap(~names, scale = "free_y")+
  theme_classic()

zone_stats %>% 
  left_join(pks_w3, by = "ID") %>% 
  select(-wshed) %>% 
  pivot_longer(c(-pk, -ID), values_to = "value", names_to = "names") %>% 
group_by(names) %>% 
  do(model = lm(pk ~ value, data = .)) %>%
  mutate(p_value = summary(model)$coefficients[2]) #%>%
  mutate(significant = p_value < 0.05)
```

```{r}
plot(rast("bedrock_topo.tif"))


d8 <- paste0(arsenal, "/w3_dems/1mdem_w3_d8pt.tif")
w3_sub_shed <- "w3_sub_sheds.tif"
wbt_watershed(d8_pntr = d8,
              pour_pts = w3_stic_locs_snap,
              output = w3_sub_shed)
plot(rast(w3_sub_shed))

plot(filter(rast(w3_sub_shed), w3_sub_sheds == 1))
plot(w3_outline, add = TRUE)
# within the watershed for each stic location, calculate the average of several topographic values:
# curvature, upslope area, upslope volume, total depression volume upslope
zones <- rast(w3_sub_shed)
# Zonal function- take zonal statistics
dem_r  <- resample(project(mask_dem, zones), zones, method="bilinear")
z_dem <- zonal(dem_r, zones, fun = "mean", na.rm = TRUE)
curve5 <- spatialEco::curvature(m11, type = "planform")
plot(curve5)
curv_r  <- resample(project(curve5, zones), zones, method="bilinear")

z_curv <- zonal(curv_r, zones, fun = "mean", na.rm = TRUE)

# upslope volume
bed_r  <- resample(project(k_terra, zones), zones, method="bilinear")
z_bed <- zonal(bed_r, zones, fun = "sum", na.rm = TRUE)
# total depression volume
dep_r  <- resample(project(rast(fill_output) - rast("krig_output.tif"), zones), zones, method="bilinear")
z_dep <- zonal(dep_r, zones, fun = "sum", na.rm = TRUE) %>% 
  mutate()

zone_stats <- bind_cols(z_dem, z_curv[,2], z_bed[,2], z_dep[,2]) %>% 
  as_tibble()

colnames(zone_stats) <- c("ID", "evelation", "curavture", "sub_volume", "depression_vol")

zone_stats %>% 
  left_join(pks_w3, by = "ID") %>% 
  select(-wshed) %>% 
  pivot_longer(c(-pk, -ID), values_to = "value", names_to = "names") %>% 
  ggplot(aes(x = pk, y = value, color = names))+
    geom_point()+
  geom_smooth(method = 'lm', se = FALSE)+
    facet_wrap(~names, scale = "free_y")+
  theme_classic()

zone_stats %>% 
  left_join(pks_w3, by = "ID") %>% 
  select(-wshed) %>% 
  pivot_longer(c(-pk, -ID), values_to = "value", names_to = "names") %>% 
group_by(names) %>% 
  do(model = lm(pk ~ value, data = .)) %>%
  mutate(p_value = summary(model)$coefficients[2]) #%>%
  mutate(significant = p_value < 0.05)
```

Calculate drainage areas based on bedrock topography
```{r}
plot(mask_dem - rast("bedrock_topo.tif"))
plot(k_terra)
bedrock_topo <- "bedrock_topo.tif"

bedrock_hillshade <- "./bedrock_rasters/bed_hill.tif"
wbt_hillshade(
  dem = bedrock_topo,
  output = bedrock_hillshade
)
my_colors <- colorRampPalette(c("black", "white"))(100)
par(mfrow = c(1, 3))
plot(hill, range = c(0, 32011), col = my_colors, legend = FALSE, axes = FALSE,
     main = "Surface hillshade")
plot(rast(bedrock_hillshade), range = c(0, 32000), col = my_colors, , legend = FALSE, axes = FALSE,
     main = "Bedrock hillshade")
plot(rast(bedrock_hillshade) - hill, , legend = FALSE, axes = FALSE,
     main = "Differences")

wbt_hillshade(
  dem = bedrock_topo,
  output = bedrock_hillshade
)

bed_filled <- "./bedrock_rasters/bed_fill.tif"
wbt_fill_depressions_wang_and_liu(
  dem = bedrock_topo,
  output = bed_filled
)
plot(rast(bed_filled) - rast(bedrock_topo))
plot(mask_dem - rast(bed_filled))

#calculate flow accumulation and direction
bed_flowacc <- "./bedrock_rasters/bed_flowacc.tif"
wbt_d8_flow_accumulation(input = bed_filled,
                         output = bed_flowacc)
bed_d8pt <- "./bedrock_rasters/bed_d8pt.tif"
wbt_d8_pointer(dem = bed_filled,
               output = bed_d8pt)
#plot(rast(zz_d8pt))


#delineate streams
bed_streams <- "./bedrock_rasters/bed_streams.tif"
wbt_extract_streams(flow_accum = bed_flowacc,
                    output = bed_streams,
                    threshold = 3000)
plot(rast(bed_streams))
points(vect(w3_stic_locs_snap))
#lines(vect_stream)
# points(lcc)
wsshape <- st_as_stars(rast(bed_streams)) %>% st_as_sf(merge = T) %>% 
  vect()
plot(wsshape)
writeVector(wsshape, "bed_streams.shp")
writeRaster()




plot(filter(rast(bed_sub_shed), w3_sub_sheds == 1))
plot(w3_outline, add = TRUE)


#snap pour point to streams
bed_stic_locs_snap <- "bed_stic_locs_snap.shp"
wbt_jenson_snap_pour_points(pour_pts = "mod_bed_points.shp",
                            streams = bed_streams,
                            output = bed_stic_locs_snap,
                            snap_dist = 10)
plot(rast(bed_streams))
lines(vect_stream)
bed_sic_locs <- vect(bed_stic_locs_snap)
points(vect(bed_stic_locs_snap))
text(bed_sic_locs)
plot(rast(bed_streams), add = TRUE)
# There is one point that is not exactly lined up correctly!
# 2. Extract coordinates of the first point
coords_df <- crds(bed_sic_locs)
# 3. Modify the x-coordinate of the first point
coords_df[17,1] <- 281700.5

# 4. Create a new SpatVector with the modified coordinates
modified_points_vec <- vect(coords_df, type = "points", crs = crs(bed_sic_locs))
modified_points_vec$ID <- bed_sic_locs$ID
points(modified_points_vec)

writeVector(modified_points_vec, "mod_bed_points.shp")


bed_sub_shed <- "./bedrock_rasters/bed_sub_sheds.tif"
wbt_watershed(d8_pntr = bed_d8pt,
              pour_pts = bed_stic_locs_snap,
              output = bed_sub_shed)
plot(rast(bed_sub_shed))
plot(rast(w3_sub_shed))
plot(rast(w3_sub_shed) - rast(bed_sub_shed))

# Plot of the different drainage areas, based on surface vs bedrock topography
p_load(RColorBrewer)
qual_col_pals = brewer.pal.info[brewer.pal.info$category == 'qual',]
col_vector = unlist(mapply(brewer.pal, qual_col_pals$maxcolors, rownames(qual_col_pals)))
n <- 32

plot_extent <- ext(rast(bed_sub_shed))

my_colors <- sample(col_vector, n)
par(mfrow = c(1, 2))
plot(crop(rast(w3_sub_shed), plot_extent), col = my_colors, legend = FALSE, 
     axes = FALSE,
     main = "Surface drainage areas")
text(vect(w3_stic_locs_snap), cex = 0.75)
plot(rast(bed_sub_shed), col = my_colors, legend = FALSE, axes = FALSE,
     main = "Bedrock drainage areas")
text(vect("mod_bed_points.shp"), cex = 0.75)
# Plot of drainage area from two different surfaces plotted against each other
subsurface <- rast(w3_sub_shed)
pixels <- subsurface
values(pixels) <- 1
z_surface <- zonal(pixels, rast(w3_sub_shed), fun = "sum", na.rm = TRUE)
subsurface <- rast(bed_sub_shed)
pixels <- subsurface
values(pixels) <- 1
z_subsurface <- zonal(pixels, rast(bed_sub_shed), fun = "sum", na.rm = TRUE)

colnames(z_surface) <- c("ID", "UAA_surface")
colnames(z_subsurface) <- c("ID", "UAA_bedrock")

comb <- left_join(z_surface, z_subsurface, by = "ID")

comb %>% 
  ggplot(aes(x = log(UAA_surface), y = log(UAA_bedrock)))+
  #geom_point()+
  geom_text(aes(label = ID))+
  geom_abline(slope = 1)+
  theme_classic()
zz_pour_snap_read <- vect("./zz_dems/zz_pour_snap.shp")
# plot(rast(zz_streams), 
#      xlim = c(280200, 280410),
#      ylim = c(4869300, 4869000))
# points(zz_pour_snap_read, pch = 1)

zz_shed <- "./zz_dems/zz_shed.tif"
# wbt_watershed(d8_pntr = zz_d8pt,
#               pour_pts = zz_pour_snap,
#               output = zz_shed)

#plot(rast(zz_shed))
#convert raster of watershed area to vector for final mapping
zz_outline <- as.polygons(rast(zz_shed), extent=FALSE)
#plot(zz_outline)

```

# Longitudinal Profiles
```{r}
exaggeration <- 3
E3_seis <- read_csv("./transect_exports_oct1/E3seis.csv") %>% 
  mutate(elevation = RASTERVALU - depth * exaggeration,
         type = "seis",
         trib = "E3") %>% 
  rename(dist = MEAS) %>% 
  select(elevation, dist, type, trib)
E4_seis <- read_csv("./transect_exports_oct1/E4seis.csv") %>% 
  mutate(elevation = RASTERVALU - depth * exaggeration,
         type = "seis",
         trib = "E4") %>% 
  rename(dist = MEAS)%>% 
  select(elevation, dist, type, trib)
W2_seis <- read_csv("./transect_exports_oct1/W2seis.csv") %>% 
  mutate(elevation = RASTERVALU - depth * exaggeration,
         type = "seis",
         trib = "W2") %>% 
  rename(dist = MEAS)%>% 
  select(elevation, dist, type, trib)
W3_seis <- read_csv("./transect_exports_oct1/W3seis.csv") %>% 
  mutate(elevation = RASTERVALU - depth * exaggeration,
         type = "seis",
         trib = "W3") %>% 
  rename(dist = MEAS)%>% 
  select(elevation, dist, type, trib)

E3_stics <- read_csv("./transect_exports_oct1/E3stics.csv") %>% 
  select(MEAS, ID, RASTERVALU) %>% 
  rename(dist = MEAS, elevation = RASTERVALU) %>% 
  mutate(type = "stics",
         trib = "E3")
E4_stics <- read_csv("./transect_exports_oct1/E4stics.csv") %>% 
  select(MEAS, ID, RASTERVALU) %>% 
  rename(dist = MEAS, elevation = RASTERVALU) %>% 
  mutate(type = "stics",
         trib = "E4")
W2_stics <- read_csv("./transect_exports_oct1/W2stics.csv") %>% 
  select(MEAS, ID, RASTERVALU) %>% 
  rename(dist = MEAS, elevation = RASTERVALU) %>% 
  mutate(type = "stics",
         trib = "W2")
W3_stics <- read_csv("./transect_exports_oct1/W3stics.csv") %>% 
  select(MEAS, ID, RASTERVALU) %>% 
  rename(dist = MEAS, elevation = RASTERVALU) %>% 
  mutate(type = "stics",
         trib = "W3")

E3_surface <- read_csv("./transect_exports_oct1/E3surface.csv") %>% 
  select(POINT_M, RASTERVALU) %>% 
  rename(dist = POINT_M, elevation = RASTERVALU) %>% 
  mutate(type = "surface",
         trib = "E3")
E4_surface <- read_csv("./transect_exports_oct1/E4surface.csv") %>% 
  select(POINT_M, RASTERVALU) %>% 
  rename(dist = POINT_M, elevation = RASTERVALU) %>% 
  mutate(type = "surface",
         trib = "E4")
W2_surface <- read_csv("./transect_exports_oct1/W2surface.csv") %>% 
  select(POINT_M, RASTERVALU) %>% 
  rename(dist = POINT_M, elevation = RASTERVALU) %>% 
  mutate(type = "surface",
         trib = "W2")
W3_surface <- read_csv("./transect_exports_oct1/W3surface.csv") %>% 
  select(ORIG_LEN, RASTERVALU) %>% 
  rename(dist = ORIG_LEN, elevation = RASTERVALU) %>% 
  mutate(type = "surface",
         trib = "W3")
stics <- rbind(E3_stics,
               E4_stics,
               W2_stics,
               W3_stics) %>% 
  left_join(pks_w3, by = "ID")

rbind(E3_seis, E3_surface,
      E4_seis, E4_surface,
      W2_seis, W2_surface,
      W3_seis, W3_surface) %>% 
  drop_na() %>% 
  ggplot(aes(x = dist, y = elevation))+
  geom_line(aes(lty = type))+
  scale_linetype_manual(values = c(2, 1), 
                        name = "")+
  theme_classic()+
    #  scale_x_reverse()+
  geom_point(data = stics, aes(x = dist, y = elevation, fill = pk),
             size = 4, pch = 21)+
  scale_fill_viridis_c()+
  facet_wrap(~trib, scales = "free")


plot1 <- fungal %>% 
  #select(grilla_number, sum, elevation_m, surfaceMinusDepth) %>% 
  rename(Surface = RASTERVALU, Bedrock = bedrock) %>% 
  mutate(Bedrock = Bedrock) %>% 
  pivot_longer(cols = c(Surface, Bedrock)) %>% 
  ggplot(aes(x = cum_dist_m, y = value))+
  geom_line(aes(lty = name))+
  #error bars are so small, not worth showing
      #  geom_errorbar(aes(ymin=bedrock_sd_n, ymax=bedrock_sd_p))+
  geom_point(data = fungal,
            aes(x = cum_dist_m, y = bedrock))+
    theme_classic()+
      scale_x_reverse()+
  geom_point(data = stic_xsec, 
             aes(x = cum_dist_m, y = RASTERVALU, color = pk), size = 3)+
  geom_text(data = stic_xsec, 
             aes(x = cum_dist_m, y = RASTERVALU, 
                 label = paste0(signif(pk, 2), "%")),
            nudge_x = 20,
            nudge_y = 10)+
  labs(x = "Distance to outlet (m)",
       y = "Elevation (m)")+
  scale_linetype_manual(values = c(2, 1), 
                        name = "")+
  scale_color_continuous(type = "gradient",
                         name = "Flow Duration",
                         breaks = c(50, 70, 90),
                         #limits = c(0.5, 1),
                        labels = c("50%", "70%", "90%"))
plot1
```


old code- will not work now, input datasets have changed

```{r}
#now that I have all of these datasets, I need to clip them to the extent of watershed 3


#wells
wells_vect <- vect(wells, geom=c("Longitude", "Latitude"), crs="epsg:4326", keepgeom=FALSE)
wells_vect_proj <- project(wells_vect, crs(dem))
plot(wells_vect)
wells_rast <- rasterize(wells_vect_proj, mask_dem, field = "Max_depth", fun = "mean")
plot(wells_rast)

#soils pits
scott <- mutate(scott, depth = depthclass * 25)
scott_vect <- vect(scott, geom=c("easting", "northing"), crs=crs1, keepgeom=FALSE)
plot(scott_vect)
# Create new column filled with default colour
scott_vect$Colour="black"
# Set new column values to appropriate colours
scott_vect$Colour[scott_vect$depthclass>=3]="red"
scott_vect$Colour[scott_vect$depthclass<=2]="blue"

scott_rast <- rasterize(scott_vect, mask_dem, field = "depth", fun = "mean")
plot(scott_rast)

avg <- ((scott_rast + wells_rast))
ra <- aggregate(r, 10)

#attempt to interpolate a depth model from these two datasets and DEM
xy <- data.frame(xyFromCell(scott_rast, 1:ncell(scott_rast)))
v <- values(scott_rast)
i <- !is.na(v)
xy <- xy[i,]
v <- v[i]

tps <- Tps(xy, v)
p <- rast(scott_rast)

# use model to predict values at all locations
p <- interpolate(p, tps)
p <- mask(p, mask_dem)
plot(p)
points(wells_vect_proj, cex = wells_vect_proj$Max_depth/200)
points(scott_vect, cex = scott_vect$depth / 200)
lines(w3_stream, col = "blue")
plot(mask(crop(soil, w3), w3))
plot(avg)

se <- interpolate(rast(p), tps, fun=predictSE)
se <- mask(se, mask_dem)
plot(se)
#interpolate point measurements into rasters with the same resolution as the DEM
#OR all measurements in a cell go into a fitted normal distribution, describing the depths observed in that cell. By assuming a normal distribution, I can just add the means and sd or the distributions themselves to combine them.
#all cells with have a mean and sd associated with them. This will incorporate uncertainty into the model of soil depth.

#assign a confidence to each measurement, using a normal distribution.

#scott dataset 1, converting uniform distribution to a normal
u1 <- runif(10000, min = 0, max = 1)
u2 <- runif(10000, min = 0, max = 1)
z1 <- sqrt(-2 * log(u1)) * sin(2*3.14*u2)
z2 <- sqrt(-2 * log(u2)) * sin(2*3.14*u1)
hist(u1)
hist(z1)

```

```{r}
# 6/12/24
#trying to find locations where we know how deep it is to take seismic measurements.
#randomly sample Scott's soil pits, just to see how well they do with some deep and shallow depth classes

deep <- scott %>% filter(grepl("WS3", pedon)) %>% 
  sample_n(20, replace = FALSE)

shallow <- scott %>% filter(depthclass == 1) %>% 
  sample_n(10, replace = FALSE)

all <- rbind(deep, shallow)
write.csv(deep, "soildepth_test_sample.csv")
```

```{r}
# 6/17/24
#read in cone pond pedons
cone <- read_csv("https://portal.edirepository.org/nis/dataviewer?packageid=knb-lter-hbr.385.1&entityid=9ce4f5893bdd16914d116fe38486a01c")
#cone pond pedon descriptions
desc0 <- read_csv("https://portal.edirepository.org/nis/dataviewer?packageid=knb-lter-hbr.385.1&entityid=7928b6c41dbbd09b52ffa041443087f6")

scott2 <- read_csv("https://portal.edirepository.org/nis/dataviewer?packageid=knb-lter-hbr.361.3&entityid=bb91029a464278a2e47451aafec435c2")
#subsetting for examples of Inceptisol descriptions
incept <- scott %>% filter(hpu == "I")
incept2 <- scott2 %>% filter(hpu == "I")
incept3 <- cone %>% filter(hpu == "I")

#read in pedon descriptions
desc1 <- read_csv("https://portal.edirepository.org/nis/dataviewer?packageid=knb-lter-hbr.210.2&entityid=407e3b6b8b88aaf095f15efeb865efd6")

lat <- read_csv("https://portal.edirepository.org/nis/dataviewer?packageid=knb-lter-hbr.361.3&entityid=cca9cc4a0a7218d0602aede8f3f8697e")

desc0 <- read_csv("https://portal.edirepository.org/nis/dataviewer?packageid=knb-lter-hbr.385.1&entityid=7928b6c41dbbd09b52ffa041443087f6")

#filter descriptions for Inceptisol horizons
info <- filter(desc1, pedon %in% incept$pedon)
info2 <- filter(lat, pedon %in% incept2$pedon)
info3 <- filter(desc0, pedon %in% incept3$pedon)

write.csv(info, "HB_inceptisols.csv")
write.csv(incept, "incept_locs.csv")

write.csv(info2, "LatWeathering_Inceptisols.csv")
write.csv(info3, "ConePond_Inceptisols.csv")

head(info2)
```

```{r}
# 7/10/24
# making figure for coop meeting- failed, had to make it in arc
seis2 <- read_csv("HVSR_7_24.csv")

seis <- seis2 %>% 
  select(grilla_number, lat, long, quality, depth) %>% 
  filter(quality != "not sesame")
seis$depth <- as.numeric(seis$depth)
write_csv(seis, "HVSR_for_arc.csv")

seis_vect <- vect(seis, geom=c("long", "lat"), crs="epsg:4326", keepgeom=FALSE)
seis_vect_p <- project(seis_vect, crs(w3))

ggplot()+
  geom_spatvector(data = w3)+
  geom_point(data=seis, aes(x = long, y = lat, color = depth))


```

```{r}
# 7/13/24
# making figure for Kevin of the dynamic nature of throughflow
# use pour point to get DEM, and calculate watershed boundary
# pour point of w3
w3_coords <- c(281543.36, 4870433.54)
#create pour point shapefile
#make dataframe
pourpoint <- data.frame("easting" = c(w3_coords[1]),
                        "northing" = c(w3_coords[2]))
pourpoint_vect <- vect(pourpoint, geom=c("easting", "northing"), crs="epsg:26919", keepgeom=FALSE)


```

```{r}
# 7/18/24
# redoing calibration curve
cali <- read_csv("calicurve_wells.csv")
all_cali <- read_csv("all_cali.csv")

plot(cali$freq, cali$depth)
model <- lm(log(cali$depth)~log(cali$freq))


#calculate what the shear wave velocity should be
cali$Vs <- cali$freq * 4 * cali$depth
summary(cali$Vs)

#plot showing only well calibration sites
cali %>% 
  reframe(avg = mean(freq), depth = depth, sd = sd(freq), .by = well) %>% 
  unique() %>% 
ggplot(aes(x = log(avg), y = log(depth)))+
  geom_point()+
  geom_errorbar(aes(xmin=log(avg-sd), xmax=log(avg+sd)))+
  geom_abline(intercept = model$coefficients[1],slope = model$coefficients[2],
              linetype="dashed")+
  geom_text_repel(aes(label = well))+
  theme_classic()+
  labs(title = "Just well calibration sites",
       x = "Ln of Peak Resonance Frequency (Hz)",
       y = "Ln Depth to bedrock (m)")

#well calibration not in log scale
model_lm <- lm((cali$depth)~(cali$freq))

cali %>% 
  reframe(avg = mean(freq), depth = depth, sd = sd(freq), .by = well) %>% 
  unique() %>% 
ggplot(aes(x = (avg), y = (depth)))+
  geom_point()+
  geom_errorbar(aes(xmin=(avg-sd), xmax=(avg+sd)))+
  geom_abline(intercept = model_lm$coefficients[1],slope = model_lm$coefficients[2],
              linetype="dashed")+
  geom_text_repel(aes(label = well))+
  theme_classic()+
  labs(title = "Well calibration sites",
       x = "Peak Resonance Frequency (Hz)",
       y = "Depth to bedrock (m)")

#plot showing all calibration sites
all_cali %>% 
  select(h_v_max, 'max depth', type, quality) %>% 
  rename(depth = 'max depth') %>% 
  na.omit() %>% 
  filter(depth != 12) %>% 
ggplot()+
  geom_point(aes(x = h_v_max, y =  depth, color = type))+
  theme_classic()+
  labs(title = "All calibration sites",
       x = "Peak Resonance Frequency (Hz)",
       y = "Depth to bedrock (m)")
  # scale_x_continuous(trans='log2')+
  # scale_y_continuous(trans='log2')

#plot showing only the highest quality measurements
  all_cali %>% 
  select(h_v_max, 'max depth', type, quality) %>% 
  rename(depth = 'max depth') %>% 
  na.omit() %>% 
  filter(depth != 12) %>% 
  filter(quality == "yes") %>% 
ggplot(aes(x = h_v_max, y =  depth))+
  geom_point(aes(color = type))+
    geom_smooth(method = 'lm', se = FALSE)+
    theme_classic()+
  labs(title = "Only high confidence calibration sites",
       x = "Peak Resonance Frequency (Hz)",
       y = "Depth to bedrock (m)")
  
good <-   all_cali %>% 
  select(h_v_max, 'max depth', type, quality, Vs_min, Vs_max) %>% 
  rename(depth = 'max depth') %>% 
  na.omit() %>% 
  filter(depth != 12) %>% 
  filter(quality == "yes") 
  
mean(good$Vs_min)
```
