---
title: "gathering_data_4_18_24"
format: html
editor: visual
editor_options: 
  chunk_output_type: console
---

## Seismic field plan for summer 24

Gathering datasets to use to plan where seismic measurements will be made.

```{r setup-and-formatting-input-data}
library(pacman)
p_load(tidyverse, sp, mapview, tmap, stars,
       lubridate, gganimate, animation, patchwork, ggrepel, whitebox,
       terra,  tidyterra, mapview, ggnewscale, googlesheets4,
       gstat, # Variogram and krig functions
       spatialEco, # Curvature function
       RColorBrewer, # set up color scales for plots later
       plotly,
       mapedit,
       lwgeom # function to split lines at points
       )
# Projection and file locations #####
crs1 <- "PROJCRS[\"NAD83 / UTM zone 19N\",\n    BASEGEOGCRS[\"NAD83\",\n        DATUM[\"North American Datum 1983\",\n            ELLIPSOID[\"GRS 1980\",6378137,298.257222101,\n                LENGTHUNIT[\"metre\",1]]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4269]],\n    CONVERSION[\"UTM zone 19N\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",-69,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",0.9996,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",500000,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",0,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"(E)\",east,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"(N)\",north,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"Engineering survey, topographic mapping.\"],\n        AREA[\"North America - between 72°W and 66°W - onshore and offshore. Canada - Labrador; New Brunswick; Nova Scotia; Nunavut; Quebec. Puerto Rico. United States (USA) - Connecticut; Maine; Massachusetts; New Hampshire; New York (Long Island); Rhode Island; Vermont.\"],\n        BBOX[14.92,-72,84,-66]],\n    ID[\"EPSG\",26919]]"
#gathering datasets
# GIS files working directory
arsenal <- "/Users/johnmorgan/Documents/VT Research/HBTopmodel"
# Shed outline, stream network and DEM prep ####
#watershed shapes to clip and mask by
#watershed boundary
w3_shed_location <- paste0(arsenal, "/w3_dems/w3_shed.tif")
w3_outline <- as.polygons(rast(w3_shed_location), extent=FALSE)
plot(w3_outline)

#topography- 1m bare earth DEM of the whole valley
## starting here so that when I use fill command later, it will yield depressional storage
dem_location <- paste0(arsenal, "/HB/1m hydro enforced DEM/dem1m.tif")
dem1 <- rast(dem_location) %>% 
  crop(w3_outline) %>% 
  mask(w3_outline)
dem10 <- aggregate(rast(dem_location), 10) %>% 
  crop(w3_outline) %>% 
  mask(w3_outline)
#save raster, because whitebox wants it is a files location instead of an object in R
dem10_location <- paste0(arsenal, "/w3_dems/10mdem.tif")
dem1_location <- paste0(arsenal, "/w3_dems/1mdem.tif")

writeRaster(dem10, dem10_location, overwrite = TRUE)
writeRaster(dem1, dem1_location, overwrite = TRUE)


plot(dem10)
plot(dem1)

#accurate flowlines of network
#using Carrie's flowlines
w3_stream <- vect(paste0(arsenal, "/HB/hbstream/hb42_master_startend.shp"))

w3_stream <- crop(w3_stream, w3_outline) #currently in NAD83
#classified stream map that scott sent me

# Think I will use Carrie's stream network instead of Scott's
w3_regime <- vect("~/Documents/VT Research/HB_data/headwater_streams_byflowregime/WS3_Streams_Types.shp")
plot(w3_regime) #currently in NAD83

# STIC sensor locations
stic_locs_snap_location <- paste0(arsenal, "/w3_stic_locs_snap.shp")
pks_w3 <- read_csv(paste0(arsenal, "/pks_w3.csv"))

w3_stic_locs_r <- vect(stic_locs_snap_location) %>% 
  left_join(pks_w3, by = "ID")

w3_stic_location <- "w3_stic_locs.shp"
#writeVector(w3_stic_locs_r, w3_stic_location)

# SEEP LOCATIONS
# Hubbard Brook Experimental Forest: W3 Surface Water Sampling Sites – 2009-2010
seeps <- vect("/Users/johnmorgan/Documents/VT Research/HB_Data/W3_synoptic_water_sampling_sites/W3_synoptic_water_sampling_sites.shp") %>% as_tibble()
  filter(ID %in% c("seep1", "seep2", "seep3", "seep3A"))
  as_tibble()
plot(w3_outline)
points(seeps)

# 2015 sampling sites
seeps15 <- read_csv("/Users/johnmorgan/Documents/VT Research/HB_Data/W3_synoptic_water_sampling_sites/synoptic_surface_water_chemistry_survey2015.csv") %>% 
  filter(wshed == "ws3", type == "seep")




# Read in data sources ####
#most recent soil map
#https://portal.edirepository.org/nis/mapbrowse?packageid=knb-lter-hbr.380.2
soil <- terra::rast("https://pasta.lternet.edu/package/data/eml/knb-lter-hbr/380/2/f083871fa0116b17b7398ca48eac7627")
crop_soil <- crop(soil, w3_outline)
mask_soil <- mask(crop_soil, w3_outline)
plot(mask_soil) #currently in NAD83
#locations and depths of soil pits, archive entry from Scott
#https://portal.edirepository.org/nis/metadataviewer?packageid=knb-lter-hbr.210.2
## Scott Pedons ####
scott <- read_csv("https://pasta.lternet.edu/package/data/eml/knb-lter-hbr/210/2/42d7e94aea392080e7c40877c9a5df83")
scott_vect <- vect(scott, geom = c("easting", "northing"), crs = crs1)
scott_vect <- crop(scott_vect, w3_outline)
plot(scott_vect)

scott_horizons <- read_csv("https://pasta.lternet.edu/package/data/eml/knb-lter-hbr/210/2/407e3b6b8b88aaf095f15efeb865efd6")

scott_rocks <- scott_horizons %>% 
  filter(horizon == "R") %>% 
  left_join(scott, by = "pedon") %>% 
  select(top_cm, easting, northing) %>% 
  rename(depth = top_cm) %>% 
  mutate(depth = depth/100) %>% 
  vect(., geom = c("easting", "northing"), crs = crs1) %>% 
  crop(., w3_outline)
#classifies depth with a classification column
#1 < 0.25m, 2 is 0.25 - 0.5 m, 3 is 0.5 - 1, 4 is 1 - 1.5, 5 is > 1.5
#does not include soil pits from lateral weathering drive, I think
#check this link, I think it is wrong 6/17/24
#scott2 <- read_csv()
## Lat weathering pedons ####
#lat weathering pedons
lat_locs <- read_csv("https://pasta.lternet.edu/package/data/eml/knb-lter-hbr/361/3/bb91029a464278a2e47451aafec435c2") %>% 
  filter(base == "R")
#unsure if filtering just by base == R is enough, or if I should also filter to horizon == R
lat_depth <- read_csv("https://pasta.lternet.edu/package/data/eml/knb-lter-hbr/361/3/cca9cc4a0a7218d0602aede8f3f8697e") 
just_depths <- lat_depth %>% 
  select(pedon, base_cm) %>% 
  group_by(pedon) %>% 
  summarize(depth = max(base_cm))

lat_hit_rock <- 
  lat_locs %>% 
  left_join(just_depths, by = "pedon") %>% 
  select(easting, northing, depth) %>% 
  vect(., geom = c("easting", "northing"), crs = crs1) %>% 
  mutate(depth = depth/100)


plot(lat_hit_rock)
#GPR results

## GW wells ####
#groundwater well locations with associated depth
#metadata: https://portal.edirepository.org/nis/metadataviewer?packageid=knb-lter-hbr.161.4
#depth in cm
wells <- read_csv("https://pasta.lternet.edu/package/data/eml/knb-lter-hbr/161/4/1549ca484d74e547def10197e8c502dc") 
wells <- wells %>% mutate(Well_ID = toupper(Well_ID))

wells_depth <- read_csv("gw_wells_depth_to_rock.csv") %>% 
  rename(depth = "Depth to rock (m)",
         Well_ID = Name) %>% 
  select(Well_ID, depth) %>% 
  filter(depth != "-") %>% 
  mutate(depth = as.numeric(depth))
wells_vect <- wells %>% 
  left_join(wells_depth, by = "Well_ID") %>% 
  select(Latitude, Longitude, depth) %>%
  drop_na() %>% 
  vect(., geom = c("Longitude", "Latitude"), crs = "epsg:4326") %>% 
  terra::project(., crs(w3_outline)) 
# turns out there are only 4 deep wells with the depth associated...
plot(wells_vect)
#also have water depths: https://portal.edirepository.org/nis/dataviewer?packageid=knb-lter-hbr.161.4&entityid=32a138fa201cbe3b7d6766cadb266cba

## 1994 rocks ####
#outcrops, from 1994 geologic map
rocks_1994 <- vect('~/Documents/VT Research/HBTopModel/HB/hbef_outcrops') %>% 
  crop(w3_outline)
# Other geologic map: 
# https://pubs.usgs.gov/of/2000/of00-045/of0045p1.pdf

## My rocks ####
john_rocks <- read_csv("JM_bedrock_outcrops.csv") %>% 
  select(lat, long) %>% 
  mutate(depth = as.numeric(0),
         source = "john_outcrops") %>% 
  vect(., geom = c("long", "lat"), crs = "epsg:4326") %>% 
    terra::project(., crs(w3_outline)) 


## My passive seismic measurements #########
seis <- read_csv("HB_HVSR_10_13_25.csv") %>% 
  select(grilla_number, lat, long, depth) %>% 
  #filter(quality != "not sesame") %>% 
  filter(depth != "#DIV/0") %>% 
  mutate(depth = as.numeric(depth)) #%>% 
  
seis$depth <- as.numeric(seis$depth)

seis_vect <- vect(seis, geom=c("long", "lat"), crs="epsg:4326", keepgeom=FALSE) %>% 
  terra::project(crs(w3_outline))
plot(seis_vect)

## 2019 REU auger investigation #########
# unclear what the best way to filter it will be...
read_csv("auger_depths.csv") %>% 
  rename(Site = "Site Name",
         Sub = "Subwatershed",
         interface = "Bottom Interface") %>% 
  left_join(read_csv("auger_locations_topo.csv"), by = c("Sub", "Site")) %>% 
  filter(interface == "R",
         Horizon == "R") %>% 
  select(Sub, Site, 'Top (cm)', x, y)

#filter 2019 auger investigation to just bedrock depths
auger <- read_csv("auger_depths.csv") %>% 
  rename(Site = "Site Name",
         Sub = "Subwatershed",
         interface = "Bottom Interface",
         top_cm = "Top (cm)") %>% 
  left_join(read_csv("auger_locations_topo.csv"), by = c("Sub", "Site")) %>% 
  filter(interface == "R") %>% 
  select(Sub, Site, top_cm, x, y) %>%
  group_by(Site, x, y, Sub) %>% 
  summarise(depth = max(top_cm)/100) %>% 
  ungroup() %>% 
  select(x, y, depth) %>% 
  mutate(source = "2019_auger") %>% 
    vect(., geom = c("x", "y"), crs = crs1)

```
```{r unused-datasets}
#soil depth from valley wide veg plots, from battles and fahey
#https://www.proquest.com/docview/304689277?pq-origsite=gscholar&fromopenview=true&sourcetype=Dissertations%20&%20Theses
# measured soil depth by inserting a steel probe until obstruction was encountered
# DOES NOT HAVE MEASUREMENTS IN W3
# fahey <- read_csv("https://pasta.lternet.edu/package/data/eml/knb-lter-hbr/121/5/d2a6900ad5470d00dce0d7fa0bca3eec") %>% vect(., geom = c("UTM_EASTING", "UTM_NORTHING"), crs = crs1)
# plot(fahey)
# plot(w3_outline, add = TRUE)
# plot(crop(fahey, w3_outline))


# Lat weathing rock https://drive.google.com/drive/folders/12HvDyet8GgEi490Ms0cnigfCRlMjnurT
#delineated rocky areas for Scott's 2019 paper
lat_rock <- vect("./ws3bedrock_latweathering/ws3bdrclip.shp")
plot(w3_outline)
plot(lat_rock, add = TRUE)

#Ksat measurements in W3
# Has depth associated with it but I am not sure that it is actually helpful
# ksat <- read_csv("https://pasta.lternet.edu/package/data/eml/knb-lter-hbr/364/1/1716abc55e229147fe45d60cbe7a4b65")

```


6 sources of depth:
- my seismic measurements
- 2019 depth surveys that hit rock
- wells that hit rock
- soil pits that hit rock
- my observations of bedrock outcrops
- 1994 geologic map outcrops
```{r combine-inputs}
# chunk to create depth shapefile, of points with appropriate information
# start with just my seismic measurements
all_sources <-
rbind(
#seis_sf2 <- 
  seis %>% 
group_by(lat, long) %>%       
  #remove duplicate locations by taking the mean
  summarise(mean_depth = mean(depth), n_coords = n()) %>% # n() is for looking duplicate number
  arrange(desc(n_coords)) %>%
  st_as_sf(coords = c("long", "lat"), crs = 4329) %>% 
  st_transform(crs1) %>% 
  rename(depth = mean_depth) %>% 
  select(depth) %>% 
  mutate(source = "seismic"),

st_as_sf(auger) %>% 
  mutate(source = "2019_auger"),

st_as_sf(wells_vect) %>% 
  mutate(source = "gw_wells"),

st_as_sf(lat_hit_rock) %>% 
  mutate(source = "lat_weathering"),

st_as_sf(scott_rocks) %>% 
  mutate(source = "scott_pedons"),

st_as_sf(rocks_1994) %>% 
  mutate(source = "rocks_1994",
         depth = as.numeric(0)) %>% 
  select(depth, geometry, source),

st_as_sf(john_rocks))


# input to kriging needs to be an sf object

# make a map showing input datasets and where they have coverage
combin_norm <- vect(all_sources)
  
ggplot()+
  geom_sf(data = w3_outline, fill = NA, alpha = 0.3, lwd = 1)+
  geom_sf(data = w3_stream, colour = "#9AC0CD", lwd = 1) +
  geom_sf(data = combin_norm, aes(fill = depth), size = 1, pch = 21) +
  
  scale_fill_gradient(high = "#27408B", low = "white")+
  facet_wrap(~source, ncol= 4)+
  theme_classic()+
  #geom_sf(data = w3_pour, colour = "black") +
   #scale_fill_hypso_c(palette = "dem_screen" , limits = c(200, 1000))+
  theme(rect = element_rect(fill = "transparent", color = NA),
        axis.title.x = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.line.x = element_blank(),
        axis.title.y = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.line.y = element_blank())
```

Krig again, but per Yang's suggestion exclude a validation dataset and use it to calculate RMSE
```{r krig-with-split}
# Krig with validation split
# input params
spatial_resolution <- 1 # meters
split <- 0.8 # 80/20 for example
number_of_classes <- 5 # number of classes for stratified random sampling
set.seed(1)

# define area for interpolation
grd <- st_bbox(w3_outline) |>
  st_as_stars(dx = spatial_resolution)

# remove auger exploration
no_auger <- filter(all_sources, source != "2019_auger")

# create depth classes for stratified random sampling
df_form <- as_tibble(no_auger)
df_form$group_equal_range <- cut(df_form$depth, breaks = number_of_classes, labels = FALSE)

# training versus validation split
training <- df_form %>% 
  group_by(group_equal_range) %>% 
  slice_sample(, prop = split)

validation <- anti_join(df_form, training)
training_sf <- st_as_sf(training)
validation_vect <- vect(st_as_sf(validation))

# calculate the sample variogram and experimental variogram
v <- variogram(depth~1, training_sf)
v.m <- fit.variogram(v, vgm(1, "Exp", 10, 1))

# run krige
k <- krige(depth~1, training_sf, grd, v.m)

# calculate RMSE using validation split, return it
extract(rast(k), validation_vect, ID = FALSE, bind = TRUE) %>% 
  as_tibble() %>% 
  drop_na() %>% 
  summarise(RMSE = sqrt(mean((depth - var1.pred_var1.pred)^2)))

# Save Raster output
k_terra <- rast(k) %>% 
  crop(w3_outline) %>% 
  mask(w3_outline) %>% 
  select(var1.pred_var1.pred)
# Save output krigged map for whitebox operations
plot(k_terra)

krig_location <- "krig_output.tif"
writeRaster(k_terra, krig_location, overwrite = TRUE)

```
```{r krig-output-map}
#map of watershed 3 with depth to bedrock
hillshade_location <- paste0(arsenal, "/w3_dems/1mdem_hillshade.tif")
hill <- rast(hillshade_location) %>% 
  crop(w3_outline) %>% 
  mask(w3_outline)


# Viridis plot
ggplot()+
  geom_spatraster(data = hill)+
  theme_void()+
  #theme(legend.position = "")+
  scale_fill_gradientn(colors = c("gray9", "gray48","lightgray", "white"),
                       na.value = "transparent",
                       guide = "none")+
    new_scale_fill() +
  geom_spatraster(data = k_terra, aes(fill = var1.pred_var1.pred))+
  scale_fill_viridis_c(na.value = "transparent", alpha = 0.7, name = "Depth (m)")+
    geom_sf(data = w3_stream, colour = "lightgray") +
geom_sf(data = as.contour(dem1, nlevels = 30), color = "white", alpha = 0.3)+
  ggspatial::annotation_scale(location = 'tr',
                              pad_x = unit(0.4, "cm"),
                              pad_y = unit(1, "cm"))

# one color plot, using magma color scheme
ggplot()+
  theme_void()+
  geom_spatraster(data = hill)+
  theme_void()+
  #theme(legend.position = "")+
  scale_fill_gradientn(colors = c("gray9", "gray48","lightgray", "white"),
                       na.value = "transparent",
                       guide = "none")+
    new_scale_fill() +
  #theme(legend.position = "")+
  geom_spatraster(data = k_terra, 
                  aes(fill = var1.pred_var1.pred),
                  alpha = 0.7)+
    scale_fill_viridis_c(na.value = "transparent", name = "Depth (m)",option = "magma")+
  geom_sf(data = as.contour(dem1, nlevels = 30), color = "white", alpha = 0.1)+
      geom_sf(data = w3_regime, colour = "lightgray") +

  new_scale_fill()+
geom_sf(data = w3_stic_locs_r, aes(fill = pk), size = 3, pch = 21) +
#geom_sf(data = seeps, pch = 19, size = 3, color = "black") +
  #add point locations of seismic measurements
    geom_sf(data = combin_norm, alpha = 0.5, size = 0.5) +
#geom_sf(data = combin_norm, aes(fill = depth), size = 3, pch = 21) +
# geom_text(data = seeps, aes(label = ID, geometry = geometry),
#                      stat = "sf_coordinates",
#                      nudge_x = 25, nudge_y = 25)  #scale_fill_manual(values = c("white", "grey", "black"), type = "binned")+
  #scale_fill_fermenter(n.breaks = 6, palette = "Greys")+
  #scale_fill_gradient(high = "#27408B", low = "white", guide = "none")+
  #scale_fill_viridis_c(na.value = "transparent", name = "Depth (m)")+
  binned_scale(aesthetics = "fill",
               scale_name = "stepsn", 
               palette = function(x) c("#F0F2FA", "#B3C0E5","#4969C1", "#2A3F7A"),
               breaks = c(0.25, 0.5, 0.75),
               limits = c(0, 1),
               show.limits = TRUE, 
               guide = "colorsteps"
  )+
  ggspatial::annotation_scale(location = 'tr',
                              pad_x = unit(0.4, "cm"),
                              pad_y = unit(1, "cm"))+
    guides(colour = guide_coloursteps(show.limits = TRUE))

# plot of where validation points were good or bad
# calculate RMSE using validation split, return it
errors <- extract(rast(k), validation_vect, ID = FALSE, bind = TRUE) %>% 
  mutate(error = depth - var1.pred_var1.pred)

ggplot()+
  theme_void()+
  geom_spatraster(data = hill)+
  theme_void()+
  #theme(legend.position = "")+
  scale_fill_gradientn(colors = c("gray9", "gray48","lightgray", "white"),
                       na.value = "transparent",
                       guide = "none")+
    new_scale_fill() +
  #theme(legend.position = "")+
  geom_spatraster(data = k_terra, 
                  aes(fill = var1.pred_var1.pred),
                  alpha = 0.7)+
    scale_fill_viridis_c(na.value = "transparent", name = "Depth (m)",option = "magma")+
  geom_sf(data = as.contour(dem1, nlevels = 30), color = "white", alpha = 0.1)+
      geom_sf(data = w3_regime, colour = "lightgray") +

  new_scale_fill()+
# geom_sf(data = errors, aes(fill = error), size = 3, pch = 21) +
#   scale_fill_gradient2()+
  ggspatial::annotation_scale(location = 'tr',
                              pad_x = unit(0.4, "cm"),
                              pad_y = unit(1, "cm"))+
    guides(colour = guide_coloursteps(show.limits = TRUE))

```
```{r}
# try to use mapview and mapedit to manually select stream reaches of interest

m <- mapview(st_as_sf(w3_regime), legend = TRUE)
m
W2 <- w3_regime[c(90, 9, 91, 7, 8, 10, 11, 41, 78),]
W2 <- terra::aggregate(W2)
W3 <- w3_regime[c(77, 33, 75, 76),]
E3 <- w3_regime[c(2, 3, 4, 5, 13, 16, 65),]
E4 <- w3_regime[c(14, 25, 70),]

plot(W2, add = TRUE, col = "red")

# testing generating points along lines
plot(w3_regime)

# find total length first, then use to generate points along line
points_along_line <- spsample(as(st_as_sf(W2), "Spatial"), n = 100, type = "regular")
points(points_along_line)

# now all I have to do is extract values from the depth-DEM and I can plot again
bedrock_topo <- rast(bedrock_topo_location)
bedrock_surface <- extract(bedrock_topo, vect(points_along_line), xy = TRUE, ID = FALSE, bind = TRUE) %>% as_tibble()

# This doesn't look right, once again failed to do this, will have to do it later in ARC
```

```{r depressions-plot}
# prepare kriging output

k_resamp <- resample(k_terra, dem1, method = "bilinear")
plot(dem1 - k_resamp)
# Save bedrock topography raster
bedrock_topo_location <- "bedrock_topo.tif"
writeRaster(dem1 - k_terra, 
            bedrock_topo_location, 
            overwrite = TRUE, NAflag=-9999, 
            gdal="COMPRESS=NONE")

# calculate filled bedrock topography
# can specify which of these to use
filled_krig_out <- "filled_krig.tif"
wbt_fill_depressions(dem = "krig_output.tif",
                     output = filled_krig_out)
 wbt_fill_depressions_wang_and_liu(
dem = "krig_output.tif",
                     output = filled_krig_out
 )
dem1_filled_location <- paste0(arsenal, "/w3_dems/1mdem_filled.tif")

 wbt_fill_depressions(dem = dem1_location,
                     output = dem1_filled_location)
 
 plot(rast(dem1_filled_location) - rast(dem1_location))
 
diff <- rast(dem1_filled_location) - rast(dem1_location)
diff[diff == 0] <- NA
plot(diff)
 
 test <- resample(rast(dem1_filled_location) - rast(dem1_location), dem10, method = "bilinear")

plot(test)
test[test > 0.01] <- NA
plot(test)
# format inputs for surface depression plotting
surface_dep <- rast(filled_krig_out) - dem10 + k_resamp
subsurace_dep <- dem10 - rast(filled_krig_out)
plot(subsurace_dep)
contours_10m <- crop(as.contour(dem10, nlevels = 30), w3_outline)

# Final plot- 2 panels, one for surface and one for subsurface depressions
par(mfrow = c(1, 2))
plot(mask(test*10, w3_outline), main = "10m surface depressions",
     axes = FALSE)
lines(contours_10m, col = "grey", alpha = 0.2)
plot(mask(k_resamp, w3_outline), main = "10m subsurface depressions",
     axes = FALSE)
lines(contours_10m, col = "grey", alpha = 0.2)

```
```{r plot-hillshades}
# also try plotting hillshades of surface versus bedrock
# I don't think this is that useful
bedrock_topo <- "krig_output.tif"

bedrock_hillshade <- "./bedrock_rasters/bed_hill.tif"
wbt_hillshade(
  dem = bedrock_topo,
  output = bedrock_hillshade
)

surface_topo <- "10mdem_crop.tif"
surface_hillshade <- "10mdem_crop_hill.tif"
wbt_hillshade(
  dem = dem10_location,
  output = surface_hillshade
)
plot(mask(rast(bedrock_hillshade), w3_outline))
plot(rast(surface_hillshade) - mask(rast(bedrock_hillshade), w3_outline))

```


```{r calculate-topo}
# fill DEM just in case
fill_output <- "./w3_dems/10mdem_fill.tif"
wbt_fill_depressions_wang_and_liu(
  dem = dem10_location,
  output = fill_output
)

#flow accumulation/drainage area
flowacc_output <- "./w3_dems/10mdem_flowacc.tif"
wbt_d_inf_flow_accumulation(input = fill_output,
                            output = flowacc_output,
                            out_type = "Specific Contributing Area")
#Slope
slope_output <- "./w3_dems/10mdem_slope.tif"
wbt_slope(dem = fill_output,
          output = slope_output,
          units = "degrees")
#calculate TPI
tpi_output <- "./w3_dems/10mdem_tpi.tif"
wbt_relative_topographic_position(
    dem = fill_output, 
    output = tpi_output, 
    filterx=11, 
    filtery=11)
#TWI
twi_output <- "./w3_dems/10mdem_twi.tif"
wbt_wetness_index(sca = flowacc_output, #flow accumulation
                  slope = slope_output,
                  output = twi_output)

#Curvature
curve10 <- spatialEco::curvature(dem10, type = "planform")



```
```{r extract-values}
#flow accumulation/drainage area
flowacc_output <- paste0(arsenal,"/w3_dems/10mdem_flowacc.tif")

#Slope
slope_output <- paste0(arsenal,"/w3_dems/10mdem_slope.tif")

#calculate TPI
tpi_output <- paste0(arsenal,"/w3_dems/10mdem_tpi.tif")

#TWI
twi_output <- paste0(arsenal,"/w3_dems/10mdem_twi.tif")
w3_uaa <- extract(rast(flowacc_output), 
                  w3_stic_locs_r, ID = FALSE, bind = TRUE) %>% 
  rename("uaa" = `X10mdem_flowacc`) %>% 
  as_tibble() %>% 
  pivot_longer(-ID)

w3_tpi <- extract(rast(tpi_output), w3_stic_locs_r, ID = FALSE, bind = TRUE) #%>% 
  rename("tpi" = `X10mdem_tpi`) %>% 
  as_tibble() %>% 
  pivot_longer(-ID)

w3_twi <- extract(rast(twi_output), w3_stic_locs_r, ID = FALSE, bind = TRUE) %>% 
  rename("twi" = `X10mdem_twi`) %>% 
  as_tibble() %>% 
  pivot_longer(-ID)

w3_slope <- extract(rast(slope_output), w3_stic_locs_r, ID = FALSE, bind = TRUE) %>% 
  rename("slope" = `X10mdem_slope`) %>% 
  as_tibble() %>% 
  pivot_longer(-ID)

w3_curve <- extract(curve10, w3_stic_locs_r) %>% 
  rename("curvature" = dem1m) %>% 
  pivot_longer(-ID)

w3_topo <- rbind(w3_uaa, w3_twi, w3_tpi, w3_slope, w3_curve)
```
```{r zonal-stats-surface}
# Delineate watersheds for each STIC location
d8 <- paste0(arsenal, "/w3_dems/1mdem_w3_d8pt.tif")
w3_surface_sheds <- "w3_surface_sheds.tif"
wbt_watershed(d8_pntr = d8,
              pour_pts = stic_locs_snap_location,
              output = w3_surface_sheds)
plot(rast(w3_surface_sheds), col = my_colors)


# determine the average or total of different topographic variables within drainage areas
# topographic metrics at 10 m resolution
# curvature, upslope area, upslope volume, total depression volume upslope
zones <- rast(w3_surface_sheds)
# Zonal function- take zonal statistics
# evelation
dem_r  <- resample(project(dem10, zones), zones, method="bilinear")
z_dem <- zonal(dem_r, zones, fun = "mean", na.rm = TRUE)
# curvature
curv_r  <- resample(project(curve10, zones), zones, method="bilinear")
z_curv <- zonal(curv_r, zones, fun = "mean", na.rm = TRUE)
# upslope volume
bed_r  <- resample(project(k_terra, zones), zones, method="bilinear")
z_bed <- zonal(bed_r, zones, fun = "sum", na.rm = TRUE)
# average upslope depth
z_mean <- zonal(bed_r, zones, fun = "mean", na.rm = TRUE)

zone_stats_surface <- bind_cols(z_dem, z_curv[,2], z_bed[,2], z_mean[,2]) %>% 
  as_tibble()

colnames(zone_stats_surface) <- c("ID", "Elevation (m)", "Planform Curvature", "Subsurface Volume (m^3)", "Average Depth (m)")



zone_stats_surface %>% 
  left_join(pks_w3, by = "ID") %>% 
    left_join(z_surface, by = "ID") %>% 
  select(-wshed) %>% 
  pivot_longer(c(-pk, -ID), values_to = "value", names_to = "names") %>% 
group_by(names) %>% 
  do(model = lm(pk ~ value, data = .)) %>%
  mutate(p_value = summary(model)$coefficients[2],
         r2 = summary(model)$r.squared[1]) #%>%
  mutate(significant = p_value < 0.05)

```
```{r zonal-stats-SUBsurface}

## Went and manually moved points in ARC!! Now I can use them to calculate topo metrics and what not
bed_sheds <- (rast("bed_sheds2.tif")) %>% 
  crop(w3_outline) %>% 
  mask(w3_outline)

bed_sheds[bed_sheds == 0] <- NA
plot(bed_sheds, col = my_colors)

# determine the average or total of different topographic variables within drainage areas
# topographic metrics at 10 m resolution
# curvature, upslope area, upslope volume, total depression volume upslope
zones <- bed_sheds
# Zonal function- take zonal statistics
# evelation
dem_r  <- resample(project(dem10, zones), zones, method="bilinear")
z_dem <- zonal(dem_r, zones, fun = "mean", na.rm = TRUE)
# curvature
curv_r  <- resample(project(curve10, zones), zones, method="bilinear")
z_curv <- zonal(curv_r, zones, fun = "mean", na.rm = TRUE)
# upslope volume
bed_r  <- resample(project(k_terra, zones), zones, method="bilinear")
z_bed <- zonal(bed_r, zones, fun = "sum", na.rm = TRUE)
# average upslope depth
z_mean <- zonal(bed_r, zones, fun = "mean", na.rm = TRUE)

zone_stats_subsurface <- bind_cols(z_dem, z_curv[,2], z_bed[,2], z_mean[,2]) %>% 
  as_tibble()

colnames(zone_stats_subsurface) <- c("ID", "Elevation (m)", "Planform Curvature", "Subsurface Volume (m^3)", "Average Depth (m)")



zone_stats_subsurface %>% 
  left_join(pks_w3, by = "ID") %>% 
    left_join(z_subsurface, by = "ID") %>% 
  select(-wshed) %>% 
  pivot_longer(c(-pk, -ID), values_to = "value", names_to = "names") %>% 
group_by(names) %>% 
  do(model = lm(pk ~ value, data = .)) %>%
  mutate(p_value = summary(model)$coefficients[2],
         r2 = summary(model)$r.squared[1]) #%>%
  mutate(significant = p_value < 0.05)


```

```{r plot-zonal-stats}
# combine plots of zonal stats here:
# calculate the range of each of these values throughout the whole watershed
zones <- dem1
values(zones) <- 1
# Zonal function- take zonal statistics
# evelation
dem_r  <- resample(project(dem10, zones), zones, method="bilinear")
dem_min <- zonal(dem_r, zones, fun = "min", na.rm = TRUE)
dem_mean <- zonal(dem_r, zones, fun = "mean", na.rm = TRUE)
dem_max <- zonal(dem_r, zones, fun = "max", na.rm = TRUE)

# curvature
curv_r  <- resample(project(curve10, zones), zones, method="bilinear")
dem_min <- zonal(dem_r, zones, fun = "min", na.rm = TRUE)
dem_mean <- zonal(dem_r, zones, fun = "mean", na.rm = TRUE)
dem_max <- zonal(dem_r, zones, fun = "max", na.rm = TRUE)
# upslope volume
bed_r  <- resample(project(k_terra, zones), zones, method="bilinear")
dem_min <- zonal(dem_r, zones, fun = "min", na.rm = TRUE)
dem_mean <- zonal(dem_r, zones, fun = "mean", na.rm = TRUE)
dem_max <- zonal(dem_r, zones, fun = "max", na.rm = TRUE)
# average upslope depth
z_mean <- zonal(bed_r, zones, fun = "mean", na.rm = TRUE)
dem_min <- zonal(dem_r, zones, fun = "min", na.rm = TRUE)
dem_mean <- zonal(dem_r, zones, fun = "mean", na.rm = TRUE)
dem_max <- zonal(dem_r, zones, fun = "max", na.rm = TRUE)

zone_stats_whole <- bind_cols(z_dem, z_curv[,2], z_bed[,2], z_mean[,2]) %>% 
  as_tibble()

colnames(zone_stats_whole) <- c("ID", "Elevation (m)", "Planform Curvature", "Subsurface Volume (m^3)", "Average Depth (m)")
# surface
surface_stats <- zone_stats_surface %>% 
  left_join(pks_w3, by = "ID") %>% 
  left_join(z_surface, by = "ID") %>% 
  select(-wshed) %>% 
  pivot_longer(c(-pk, -ID), values_to = "value", names_to = "names") %>%
  mutate(type = "Surface")

# subsurface
sub_stats <- zone_stats_subsurface %>% 
  left_join(pks_w3, by = "ID") %>% 
  left_join(z_subsurface, by = "ID") %>% 
  select(-wshed) %>% 
  pivot_longer(c(-pk, -ID), values_to = "value", names_to = "names") %>% 
  mutate(type = "Subsurface")

combined <- rbind(surface_stats, sub_stats) 
no_curve <- combined %>% 
  filter(names != "Planform Curvature")

combined %>% 
  ggplot(aes(x = pk, y = value))+
    geom_point(aes(color = type))+
  geom_smooth(data =  no_curve,
              aes(color = type), method = 'lm', se = FALSE)+
    facet_wrap(type~names, ncol = 5, scales = "free_y", drop = TRUE)+
  scale_color_manual(values = c("lightblue4", "firebrick"))+
  theme_classic()+
  theme(strip.text.y = element_blank())
```

```{r sub-watersheds-plots}
## OLD PLOT
# Plot of the different drainage areas, based on surface vs bedrock topography

# set up colors for plotting
qual_col_pals = brewer.pal.info[brewer.pal.info$category == 'qual',]
col_vector = unlist(mapply(brewer.pal, qual_col_pals$maxcolors, rownames(qual_col_pals)))
n <- 32
my_colors <- sample(col_vector, n)

# define extent so they match, set up plot
plot_extent <- ext(bed_sheds)
par(mfrow = c(1, 2))

# plot surface drainage areas
plot(crop(rast(w3_surface_sheds), plot_extent), 
     col = my_colors, legend = FALSE, 
     axes = FALSE,
     main = "Surface drainage areas")
text(vect("mod_bed_points.shp"), cex = 0.75)

# plot subsurface drainage areas
plot(crop(bed_sheds, plot_extent),
     col = my_colors, legend = FALSE, axes = FALSE,
     main = "Bedrock drainage areas")
text(vect("mod_bed_points.shp"), cex = 0.75)
# Plot of drainage area from two different surfaces plotted against each other
surface <- rast(w3_surface_sheds)
pixels <- surface
values(pixels) <- 1
z_surface <- zonal(pixels, rast(w3_surface_sheds), fun = "sum", na.rm = TRUE)
                   
subsurface <- bed_sheds
pixels <- subsurface
values(pixels) <- 1
z_subsurface <- zonal(pixels, bed_sheds, fun = "sum", na.rm = TRUE)

colnames(z_surface) <- c("ID", "UAA_surface")
colnames(z_subsurface) <- c("ID", "UAA_bedrock")

comb <- left_join(z_surface, z_subsurface, by = "ID")

norm <- comb %>% 
  ggplot(aes(x = (UAA_surface), y = (UAA_bedrock)))+
  #geom_point()+
  geom_text(aes(label = ID))+
  geom_abline(slope = 1)+
  lims(x = c(0, 40000),
       y = c(0, 40000))+
  theme_classic()

logged <- comb %>% 
  ggplot(aes(x = log(UAA_surface), y = log(UAA_bedrock)))+
  #geom_point()+
  geom_text(aes(label = ID))+
  geom_abline(slope = 1)+
  lims(x = c(7, 11),
        y = c(7, 11))+
  theme_classic()

norm + logged

```

```{r fiddling-with-locs}

#flow accumulation/drainage area
krig_flowdir_output <- "./krig_flowdir.tif"
wbt_d8_pointer(dem = bedrock_topo_location,
               output = krig_flowdir_output)
plot(rast(krig_flowdir_output))

w3_krig_shed <- "w3_sub_sheds.tif"

wbt_watershed(d8_pntr = krig_flowdir_output,
              pour_pts = w3_stic_location,
              output = w3_krig_shed)

plot(rast(w3_krig_shed))
# do again, but for a breached and filled bedrock DEM
bedrock_topo_breach <- "bedrock_topo_breach.tif"
wbt_breach_depressions_least_cost(
  dem = bedrock_topo_location,
  output = bedrock_topo_breach,
  dist = 10,
  fill = TRUE)

bedrock_topo_filled <- "bedrock_topo_filled.tif"
wbt_fill_depressions_wang_and_liu(
  dem = bedrock_topo_breach,
  output = bedrock_topo_filled
)
plot(rast(bedrock_topo_filled))

krig_flowdir_output <- "./krig_flowdir.tif"
wbt_d8_pointer(dem = bedrock_topo_filled,
               output = krig_flowdir_output)
plot(rast(krig_flowdir_output))
w3_krig_shed <- "w3_sub_sheds.tif"

wbt_watershed(d8_pntr = krig_flowdir_output,
              pour_pts = w3_stic_location,
              output = w3_krig_shed)

plot(rast(w3_krig_shed))

## Went and manually moved points in ARC!! Now I can use them to calculate topo metrics and what not
bed_sheds <- (rast("bed_sheds2.tif")) %>% 
  crop(w3_outline) %>% 
  mask(w3_outline)

bed_sheds[bed_sheds == 0] <- NA
plot(bed_sheds, col = my_colors)
# convert flow acc to stream network and snap points
#flow accumulation/drainage area
flowacc_output <- "./export_to_arc/1mrock_flowacc.tif"
wbt_d_inf_flow_accumulation(input = bedrock_topo_location,
                            output = flowacc_output,
                            out_type = "Specific Contributing Area")
plot(rast(flowacc_output))
#delineate streams
bed_streams <- "./export_to_arc/bed_streams.tif"
wbt_extract_streams(flow_accum = flowacc_output,
                    output = bed_streams,
                    threshold = 2000)
plot(rast(bed_streams), col ="black")
points(vect(w3_stic_locs_snap))
writeVector(vect(w3_stic_locs_snap), "./export_to_arc/locs.shp")

#snap pour point to streams
bed_stic_locs_snap <- "bed_stic_locs_snap.shp"
wbt_jenson_snap_pour_points(pour_pts = w3_stic_locs_snap,
                            streams = bed_streams,
                            output = bed_stic_locs_snap,
                            snap_dist = 10)
plot(rast(bed_streams), col = "black")
points(vect(w3_stic_locs_snap), col = "black")
points(vect(bed_stic_locs_snap), col = "red")
text(vect(bed_stic_locs_snap))

coords_df <- crds(vect(bed_stic_locs_snap))
as.data.frame(vect(bed_stic_locs_snap))
# 3. Modify the x-coordinate of the first point
#coords_df[19,1] <- 281775
coords_df[20,1] <- 281775

modified_points_vec <- vect(coords_df, type = "points", crs = crs(bed_sic_locs))
#modified_points_vec$ID <- bed_stic_locs_snap$ID
plot(rast(bed_streams), col = "black")

points(modified_points_vec)

writeVector(modified_points_vec, "mod_bed_points.shp", overwrite = TRUE)


bed_stic_locs_snap_mod <- "bed_stic_locs_snap.shp"
wbt_jenson_snap_pour_points(pour_pts = "mod_bed_points.shp",
                            streams = bed_streams,
                            output = bed_stic_locs_snap_mod,
                            snap_dist = 100)
plot(rast(bed_streams), col = "black")
points(vect(w3_stic_locs_snap), col = "black")
points(vect(bed_stic_locs_snap_mod), col = "red")
text(vect(bed_stic_locs_snap))

w3_krig_shed_mod <- "krig_shed_mod.tif"
wbt_watershed(d8_pntr = krig_flowdir_output,
              pour_pts = "points_snapped_one.shp",
              output = w3_krig_shed_mod)

plot(rast(w3_krig_shed_mod), col = my_colors)
plot(rast(bed_streams), add = TRUE, col = "black")

```

```{r move-pts-function}
library(terra)

# --- Load data ---
r <- rast(flowacc_output)      # your raster
pts <- vect("points_snapped_one.shp")              # your shapefile with point locations

# --- Parameters ---
window_radius <- 10   # number of cells (or specify in map units if you want)
                     # this will define the search window around each point

# --- Function to snap each point ---
snap_to_max <- function(pt, r, window_radius) {
  # Create a square buffer (or circular) around the point
  buf <- buffer(pt, width = window_radius * res(r)[1])
  
  # Crop raster to the window area
  r_sub <- crop(r, buf)
  
  # Mask raster to the exact window
  r_masked <- mask(r_sub, buf)
  
  # Find cell with maximum value
  max_cell <- which.max(values(r_masked))
  
  # Get coordinates of that cell
  if (is.na(max_cell)) {
    return(pt)  # if no valid values, return original point
  } else {
    xy <- xyFromCell(r_masked, max_cell)
    return(vect(matrix(xy, ncol = 2), crs = crs(r), type = "points"))
  }
}

# --- Apply snapping ---
snapped_pts <- lapply(1:nrow(pts), function(i) {
  snap_to_max(pts[i], r, window_radius)
})

# Combine into a single SpatVector
snapped_pts <- do.call(rbind, snapped_pts)
plot(rast(bed_streams), col = "black")

# Specify which point to snap
i <- 3
window_radius <- 20
# Snap that one
snapped_pt <- snap_to_max(pts[i], r, window_radius)
# Make a new SpatVector combining all others + the new point
pts_snapped <- rbind(pts[1:i-1], snapped_pt, pts[i+1:31])
# Reorder rows to original order
pts_snapped <- pts_snapped[order(c(1:(i-1), nrow(pts_snapped), i:nrow(pts_snapped)-1))]

# Save
writeVector(pts_snapped, "points_snapped_one.shp", overwrite = TRUE)

points(snapped_pts)
pt <- snap_to_max(snapped_pts[3], r, 20)
snapped_pts[3] <- pt
points(, col = "black")
points(pts_snapped[3], col = "blue")

# --- Save result ---
writeVector(snapped_pts, "snapped_points.shp", overwrite = TRUE)

```


Table of metrics
```{r}
# first, delineate stream network according to topography

# convert stream network to polygon, or keep as raster, but snap STIC locations to stream network
#w3 network- thing I need to change
#read in shapefile of stream converted in ARC
vect_stream_path <- paste0(arsenal, "/AGU24posterAnalysis/vector_stream/vector_stream.shp")
#stream as a vector
vect_stream <- vect(vect_stream_path)
plot(vect_stream)


# Delineate watersheds for each STIC location
d8 <- paste0(arsenal, "/w3_dems/1mdem_w3_d8pt.tif")
w3_sub_shed <- "w3_sub_sheds.tif"
wbt_watershed(d8_pntr = d8,
              pour_pts = stic_locs_snap_location,
              output = w3_sub_shed)
plot(rast(w3_sub_shed))
plot(filter(rast(w3_sub_shed), w3_sub_sheds == 1))
plot(w3_outline, add = TRUE)
# within the watershed for each stic location, calculate the average of several topographic values:
# curvature, upslope area, upslope volume, total depression volume upslope
zones <- rast(w3_sub_shed)
# Zonal function- take zonal statistics
dem_r  <- resample(project(mask_dem, zones), zones, method="bilinear")
z_dem <- zonal(dem_r, zones, fun = "mean", na.rm = TRUE)
curve5 <- spatialEco::curvature(m11, type = "planform")
curv_r  <- resample(project(curve5, zones), zones, method="bilinear")

z_curv <- zonal(curv_r, zones, fun = "mean", na.rm = TRUE)

# upslope volume
bed_r  <- resample(project(k_terra, zones), zones, method="bilinear")
z_bed <- zonal(bed_r, zones, fun = "sum", na.rm = TRUE)
# total depression volume
dep_r  <- resample(project(rast(fill_output) - rast("krig_output.tif"), zones), zones, method="bilinear")
z_dep <- zonal(dep_r, zones, fun = "sum", na.rm = TRUE) %>% 
  mutate()

zone_stats <- bind_cols(z_dem, z_curv[,2], z_bed[,2], z_dep[,2]) %>% 
  as_tibble()

colnames(zone_stats) <- c("ID", "evelation", "curavture", "sub_volume", "depression_vol")

zone_stats %>% 
  left_join(pks_w3, by = "ID") %>% 
  select(-wshed) %>% 
  pivot_longer(c(-pk, -ID), values_to = "value", names_to = "names") %>% 
  ggplot(aes(x = pk, y = value, color = names))+
    geom_point()+
  geom_smooth(method = 'lm', se = FALSE)+
    facet_wrap(~names, scale = "free_y")+
  theme_classic()

zone_stats %>% 
  left_join(pks_w3, by = "ID") %>% 
  select(-wshed) %>% 
  pivot_longer(c(-pk, -ID), values_to = "value", names_to = "names") %>% 
group_by(names) %>% 
  do(model = lm(pk ~ value, data = .)) %>%
  mutate(p_value = summary(model)$coefficients[2]) #%>%
  mutate(significant = p_value < 0.05)
```

```{r}
plot(rast("bedrock_topo.tif"))


d8 <- paste0(arsenal, "/w3_dems/1mdem_w3_d8pt.tif")
w3_sub_shed <- "w3_sub_sheds.tif"
wbt_watershed(d8_pntr = d8,
              pour_pts = w3_stic_locs_snap,
              output = w3_sub_shed)
plot(rast(w3_sub_shed))

plot(filter(rast(w3_sub_shed), w3_sub_sheds == 1))
plot(w3_outline, add = TRUE)
# within the watershed for each stic location, calculate the average of several topographic values:
# curvature, upslope area, upslope volume, total depression volume upslope
zones <- rast(w3_sub_shed)
# Zonal function- take zonal statistics
dem_r  <- resample(project(mask_dem, zones), zones, method="bilinear")
z_dem <- zonal(dem_r, zones, fun = "mean", na.rm = TRUE)
curve5 <- spatialEco::curvature(m11, type = "planform")
plot(curve5)
curv_r  <- resample(project(curve5, zones), zones, method="bilinear")

z_curv <- zonal(curv_r, zones, fun = "mean", na.rm = TRUE)

# upslope volume
bed_r  <- resample(project(k_terra, zones), zones, method="bilinear")
z_bed <- zonal(bed_r, zones, fun = "sum", na.rm = TRUE)
# total depression volume
dep_r  <- resample(project(rast(fill_output) - rast("krig_output.tif"), zones), zones, method="bilinear")
z_dep <- zonal(dep_r, zones, fun = "sum", na.rm = TRUE) %>% 
  mutate()

zone_stats <- bind_cols(z_dem, z_curv[,2], z_bed[,2], z_dep[,2]) %>% 
  as_tibble()

colnames(zone_stats) <- c("ID", "evelation", "curavture", "sub_volume", "depression_vol")

zone_stats %>% 
  left_join(pks_w3, by = "ID") %>% 
  select(-wshed) %>% 
  pivot_longer(c(-pk, -ID), values_to = "value", names_to = "names") %>% 
  ggplot(aes(x = pk, y = value, color = names))+
    geom_point()+
  geom_smooth(method = 'lm', se = FALSE)+
    facet_wrap(~names, scale = "free_y")+
  theme_classic()

zone_stats %>% 
  left_join(pks_w3, by = "ID") %>% 
  select(-wshed) %>% 
  pivot_longer(c(-pk, -ID), values_to = "value", names_to = "names") %>% 
group_by(names) %>% 
  do(model = lm(pk ~ value, data = .)) %>%
  mutate(p_value = summary(model)$coefficients[2]) #%>%
  mutate(significant = p_value < 0.05)
```

Calculate drainage areas based on bedrock topography
```{r}
plot(mask_dem - rast("bedrock_topo.tif"))
plot(k_terra)
bedrock_topo <- "bedrock_topo.tif"

bedrock_hillshade <- "./bedrock_rasters/bed_hill.tif"
wbt_hillshade(
  dem = bedrock_topo,
  output = bedrock_hillshade
)
my_colors <- colorRampPalette(c("black", "white"))(100)
par(mfrow = c(1, 3))
plot(hill, range = c(0, 32011), col = my_colors, legend = FALSE, axes = FALSE,
     main = "Surface hillshade")
plot(rast(bedrock_hillshade), range = c(0, 32000), col = my_colors, , legend = FALSE, axes = FALSE,
     main = "Bedrock hillshade")
plot(rast(bedrock_hillshade) - hill, , legend = FALSE, axes = FALSE,
     main = "Differences")

wbt_hillshade(
  dem = bedrock_topo,
  output = bedrock_hillshade
)

bed_filled <- "./bedrock_rasters/bed_fill.tif"
wbt_fill_depressions_wang_and_liu(
  dem = bedrock_topo,
  output = bed_filled
)
plot(rast(bed_filled) - rast(bedrock_topo))
plot(mask_dem - rast(bed_filled))

#calculate flow accumulation and direction
bed_flowacc <- "./bedrock_rasters/bed_flowacc.tif"
wbt_d8_flow_accumulation(input = bed_filled,
                         output = bed_flowacc)
bed_d8pt <- "./bedrock_rasters/bed_d8pt.tif"
wbt_d8_pointer(dem = bed_filled,
               output = bed_d8pt)
#plot(rast(zz_d8pt))


#delineate streams
bed_streams <- "./bedrock_rasters/bed_streams.tif"
wbt_extract_streams(flow_accum = bed_flowacc,
                    output = bed_streams,
                    threshold = 3000)
plot(rast(bed_streams))
points(vect(w3_stic_locs_snap))
#lines(vect_stream)
# points(lcc)
wsshape <- st_as_stars(rast(bed_streams)) %>% st_as_sf(merge = T) %>% 
  vect()
plot(wsshape)
writeVector(wsshape, "bed_streams.shp")
writeRaster()




plot(filter(rast(bed_sub_shed), w3_sub_sheds == 1))
plot(w3_outline, add = TRUE)


#snap pour point to streams
bed_stic_locs_snap <- "bed_stic_locs_snap.shp"
wbt_jenson_snap_pour_points(pour_pts = "mod_bed_points.shp",
                            streams = bed_streams,
                            output = bed_stic_locs_snap,
                            snap_dist = 10)
plot(rast(bed_streams))
lines(vect_stream)
bed_sic_locs <- vect(bed_stic_locs_snap)
points(vect(bed_stic_locs_snap))
text(bed_sic_locs)
plot(rast(bed_streams), add = TRUE)
# There is one point that is not exactly lined up correctly!
# 2. Extract coordinates of the first point
coords_df <- crds(bed_sic_locs)
# 3. Modify the x-coordinate of the first point
coords_df[17,1] <- 281700.5

# 4. Create a new SpatVector with the modified coordinates
modified_points_vec <- vect(coords_df, type = "points", crs = crs(bed_sic_locs))
modified_points_vec$ID <- bed_sic_locs$ID
points(modified_points_vec)

writeVector(modified_points_vec, "mod_bed_points.shp")


bed_sub_shed <- "./bedrock_rasters/bed_sub_sheds.tif"
wbt_watershed(d8_pntr = bed_d8pt,
              pour_pts = bed_stic_locs_snap,
              output = bed_sub_shed)
plot(rast(bed_sub_shed))
plot(rast(w3_sub_shed))
plot(rast(w3_sub_shed) - rast(bed_sub_shed))


```

# Longitudinal Profiles
Relevant calculations were done in Arc
```{r Longitidunal-profiles}
exaggeration <- 3
E3_seis <- read_csv("./transect_exports_oct1/E3seis.csv") %>% 
  mutate(elevation = RASTERVALU - depth * exaggeration,
         type = "seis",
         trib = "E3") %>% 
  rename(dist = MEAS) %>% 
  select(elevation, dist, type, trib)
E4_seis <- read_csv("./transect_exports_oct1/E4seis.csv") %>% 
  mutate(elevation = RASTERVALU - depth * exaggeration,
         type = "seis",
         trib = "E4") %>% 
  rename(dist = MEAS)%>% 
  select(elevation, dist, type, trib)
W2_seis <- read_csv("./transect_exports_oct1/W2seis.csv") %>% 
  mutate(elevation = RASTERVALU - depth * exaggeration,
         type = "seis",
         trib = "W2") %>% 
  rename(dist = MEAS)%>% 
  select(elevation, dist, type, trib)
W3_seis <- read_csv("./transect_exports_oct1/W3seis.csv") %>% 
  mutate(elevation = RASTERVALU - depth * exaggeration,
         type = "seis",
         trib = "W3") %>% 
  rename(dist = MEAS)%>% 
  select(elevation, dist, type, trib)

E3_stics <- read_csv("./transect_exports_oct1/E3stics.csv") %>% 
  select(MEAS, ID, RASTERVALU) %>% 
  rename(dist = MEAS, elevation = RASTERVALU) %>% 
  mutate(type = "stics",
         trib = "E3")
E4_stics <- read_csv("./transect_exports_oct1/E4stics.csv") %>% 
  select(MEAS, ID, RASTERVALU) %>% 
  rename(dist = MEAS, elevation = RASTERVALU) %>% 
  mutate(type = "stics",
         trib = "E4")
W2_stics <- read_csv("./transect_exports_oct1/W2stics.csv") %>% 
  select(MEAS, ID, RASTERVALU) %>% 
  rename(dist = MEAS, elevation = RASTERVALU) %>% 
  mutate(type = "stics",
         trib = "W2")
W3_stics <- read_csv("./transect_exports_oct1/W3stics.csv") %>% 
  select(MEAS, ID, RASTERVALU) %>% 
  rename(dist = MEAS, elevation = RASTERVALU) %>% 
  mutate(type = "stics",
         trib = "W3")

E3_surface <- read_csv("./transect_exports_oct1/E3surface.csv") %>% 
  select(POINT_M, RASTERVALU) %>% 
  rename(dist = POINT_M, elevation = RASTERVALU) %>% 
  mutate(type = "surface",
         trib = "E3")
E4_surface <- read_csv("./transect_exports_oct1/E4surface.csv") %>% 
  select(POINT_M, RASTERVALU) %>% 
  rename(dist = POINT_M, elevation = RASTERVALU) %>% 
  mutate(type = "surface",
         trib = "E4")
W2_surface <- read_csv("./transect_exports_oct1/W2surface.csv") %>% 
  select(POINT_M, RASTERVALU) %>% 
  rename(dist = POINT_M, elevation = RASTERVALU) %>% 
  mutate(type = "surface",
         trib = "W2")
W3_surface <- read_csv("./transect_exports_oct1/W3surface.csv") %>% 
  select(ORIG_LEN, RASTERVALU) %>% 
  rename(dist = ORIG_LEN, elevation = RASTERVALU) %>% 
  mutate(type = "surface",
         trib = "W3")
stics <- rbind(E3_stics,
               E4_stics,
               W2_stics,
               W3_stics) %>% 
  left_join(pks_w3, by = "ID")

rbind(E3_seis, E3_surface,
      E4_seis, E4_surface,
      W2_seis, W2_surface,
      W3_seis, W3_surface) %>% 
  drop_na() %>% 
  ggplot(aes(x = dist, y = elevation))+
  geom_line(aes(lty = type))+
  scale_linetype_manual(values = c(2, 1), 
                        name = "")+
  theme_classic()+
    #  scale_x_reverse()+
  geom_point(data = stics, aes(x = dist, y = elevation, fill = pk),
             size = 4, pch = 21)+
  scale_fill_viridis_c()+
  facet_wrap(~trib, scales = "free")


plot1 <- fungal %>% 
  #select(grilla_number, sum, elevation_m, surfaceMinusDepth) %>% 
  rename(Surface = RASTERVALU, Bedrock = bedrock) %>% 
  mutate(Bedrock = Bedrock) %>% 
  pivot_longer(cols = c(Surface, Bedrock)) %>% 
  ggplot(aes(x = cum_dist_m, y = value))+
  geom_line(aes(lty = name))+
  #error bars are so small, not worth showing
      #  geom_errorbar(aes(ymin=bedrock_sd_n, ymax=bedrock_sd_p))+
  geom_point(data = fungal,
            aes(x = cum_dist_m, y = bedrock))+
    theme_classic()+
      scale_x_reverse()+
  geom_point(data = stic_xsec, 
             aes(x = cum_dist_m, y = RASTERVALU, color = pk), size = 3)+
  geom_text(data = stic_xsec, 
             aes(x = cum_dist_m, y = RASTERVALU, 
                 label = paste0(signif(pk, 2), "%")),
            nudge_x = 20,
            nudge_y = 10)+
  labs(x = "Distance to outlet (m)",
       y = "Elevation (m)")+
  scale_linetype_manual(values = c(2, 1), 
                        name = "")+
  scale_color_continuous(type = "gradient",
                         name = "Flow Duration",
                         breaks = c(50, 70, 90),
                         #limits = c(0.5, 1),
                        labels = c("50%", "70%", "90%"))
plot1
```

```{r calibration-curve}
# 7/18/24
# redoing calibration curve
cali <- read_csv("calicurve_wells.csv")
all_cali <- read_csv("all_cali.csv")

plot(cali$freq, cali$depth)
model <- lm(log(cali$depth)~log(cali$freq))


#calculate what the shear wave velocity should be
cali$Vs <- cali$freq * 4 * cali$depth
summary(cali$Vs)

#plot showing only well calibration sites
cali %>% 
  reframe(avg = mean(freq), depth = depth, sd = sd(freq), .by = well) %>% 
  unique() %>% 
ggplot(aes(x = log(avg), y = log(depth)))+
  geom_point()+
  geom_errorbar(aes(xmin=log(avg-sd), xmax=log(avg+sd)))+
  geom_abline(intercept = model$coefficients[1],slope = model$coefficients[2],
              linetype="dashed")+
  geom_text_repel(aes(label = well))+
  theme_classic()+
  labs(title = "Just well calibration sites",
       x = "Ln of Peak Resonance Frequency (Hz)",
       y = "Ln Depth to bedrock (m)")

#well calibration not in log scale
model_lm <- lm((cali$depth)~(cali$freq))

cali %>% 
  reframe(avg = mean(freq), depth = depth, sd = sd(freq), .by = well) %>% 
  unique() %>% 
ggplot(aes(x = (avg), y = (depth)))+
  geom_point()+
  geom_errorbar(aes(xmin=(avg-sd), xmax=(avg+sd)))+
  geom_abline(intercept = model_lm$coefficients[1],slope = model_lm$coefficients[2],
              linetype="dashed")+
  geom_text_repel(aes(label = well))+
  theme_classic()+
  labs(title = "Well calibration sites",
       x = "Peak Resonance Frequency (Hz)",
       y = "Depth to bedrock (m)")

#plot showing all calibration sites
all_cali %>% 
  select(h_v_max, 'max depth', type, quality) %>% 
  rename(depth = 'max depth') %>% 
  na.omit() %>% 
  filter(depth != 12) %>% 
ggplot()+
  geom_point(aes(x = h_v_max, y =  depth, color = type))+
  theme_classic()+
  labs(title = "All calibration sites",
       x = "Peak Resonance Frequency (Hz)",
       y = "Depth to bedrock (m)")
  # scale_x_continuous(trans='log2')+
  # scale_y_continuous(trans='log2')

#plot showing only the highest quality measurements
  all_cali %>% 
  select(h_v_max, 'max depth', type, quality) %>% 
  rename(depth = 'max depth') %>% 
  na.omit() %>% 
  filter(depth != 12) %>% 
  filter(quality == "yes") %>% 
ggplot(aes(x = h_v_max, y =  depth))+
  geom_point(aes(color = type))+
    geom_smooth(method = 'lm', se = FALSE)+
    theme_classic()+
  labs(title = "Only high confidence calibration sites",
       x = "Peak Resonance Frequency (Hz)",
       y = "Depth to bedrock (m)")
  
good <-   all_cali %>% 
  select(h_v_max, 'max depth', type, quality, Vs_min, Vs_max) %>% 
  rename(depth = 'max depth') %>% 
  na.omit() %>% 
  filter(depth != 12) %>% 
  filter(quality == "yes") 
  
mean(good$Vs_min)
```
Sanity check- take all observations not used in krig- holes not to bedrock- and see if they could be dug with this depth raster!
```{r}

```

## DEPREC
```{r orginal krig chunk}
# # chunk that will run the variogram calculation and run kriging model
# 
# # create the empty grid to hold the output of kriging
# st_bbox(w3_outline) |>
#   st_as_stars(dx = 1) -> grd
# 
# #grd <- mask_dem
# 
# # Remove empty geometries
# which(st_is_empty(all_sources))
# all_sources <- all_sources[-which(st_is_empty(all_sources)),]
# # Remove missing depth values, all 3 are in auger dataset
# which(is.na(all_sources))
# all_sources <-all_sources[-which(is.na(all_sources)),]
# 
# no_auger <- filter(all_sources, source != "2019_auger")
# 
# # calculate the sample variogram
# v <- variogram(depth~1, no_auger)
# #v <- variogram(depth~1, all_sources, cutoff = 445.8491, width = 37.15409)
# 
# # plot semivariogram
# plot(v, plot.numbers = TRUE, xlab = "distance h [m]",
#      ylab = expression(gamma(h)),
#      xlim = c(0, 1.055 * max(v$dist)))
# 
# # fit a model/variogram to the data
# v.m <- fit.variogram(v, vgm(1, "Exp", 10, 1))
# plot(v, v.m, plot.numbers = TRUE, xlab = "distance h [m]",
#      ylab = expression(gamma(h)),
#      xlim = c(0, 1.055 * max(v$dist))) ## draws a single model; draw 2 models in single plot:
# # use variogram model to krig
# k <- krige(depth~1, all_sources, grd, v.m)
```
Try multivariate approach- did not work
```{r topography-multivariate}
#extract topographic values for each input data location
combin_norm

plot(curve5)

extract(dem)
#flow accumulation/drainage area
mask_dem_location <- paste0(arsenal, "/w3_dems/1mdem_w3_masked.tif")
fill_output <- "./w3_dems/10mdem_fill.tif"



w3_uaa <- 
  extract(rast(flowacc_output), combin_norm, ID = FALSE, bind = TRUE) %>% 
  rename("uaa" = `X10mdem_flowacc`) #%>% 
  #as_tibble()

w3_tpi <- extract(rast(tpi_output), combin_norm, ID = FALSE, bind = TRUE) %>% 
  rename("tpi" = `X10mdem_tpi`) %>% 
  #as_tibble() %>% 
  select(tpi)

w3_twi <- extract(rast(twi_output), combin_norm, ID = FALSE, bind = TRUE) %>% 
  rename("twi" = `X10mdem_twi`) %>% 
  #as_tibble() %>% 
  select(twi)

w3_slope <- extract(rast(slope_output), combin_norm, ID = FALSE, bind = TRUE) %>% 
  rename("slope" = `X10mdem_slope`) %>% 
  #as_tibble() %>% 
  select(slope)

w3_topo <- bind_spat_cols(w3_uaa, w3_twi, w3_tpi, w3_slope)

all_sources2 <- st_as_sf(w3_topo)
which(st_is_empty(all_sources2))
all_sources2 <- all_sources2[-which(st_is_empty(all_sources2)),]
# Remove missing depth values, all 3 are in auger dataset
which(is.na(all_sources2))
all_sources2 <-all_sources2[-which(is.na(all_sources2)),]

no_auger <- filter(all_sources2, source != "2019_auger")

# Multivariate kriging
hscat(log(depth) ~ 1, no_auger, (0:9) * 100)

 cok.maps <- predict(vm.fit, meuse.grid)
# calculate the sample variogram
v <- variogram(depth~1, no_auger)
#v <- variogram(depth~1, all_sources, cutoff = 445.8491, width = 37.15409)

# plot semivariogram
plot(v, plot.numbers = TRUE, xlab = "distance h [m]",
     ylab = expression(gamma(h)),
     xlim = c(0, 1.055 * max(v$dist)))

# fit a model/variogram to the data
v.m <- fit.variogram(v, vgm(1, "Exp", 10, 1))
plot(v, v.m, plot.numbers = TRUE, xlab = "distance h [m]",
     ylab = expression(gamma(h)),
     xlim = c(0, 1.055 * max(v$dist))) ## draws a single model; draw 2 models in single plot:
# use variogram model to krig
k <- krige(depth~1, all_sources, grd, v.m)
```
